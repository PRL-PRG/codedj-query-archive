r"""
Permutation groups

A {\it permutation group} is a finite group G whose elements are permutations  
of a given finite set X (i.e., bijections X --> X) and whose group operation is 
the composition of permutations. The number of elements of $X$ is called the
{\it degree} of G.

In \sage a permutation is represented as either a string that defines a 
permutation using disjoint cycle notation, or a list of tuples, which represent 
disjoint cycles.

\begin{verbatim}
(a,...,b)(c,...,d)...(e,...,f)  <--> [(a,...,b), (c,...,d),..., (e,...,f)]
                  () = identity <--> []
\end{verbatim}                  
           
You can make the "named" permutation groups (see \code{permgp_named.py})
and use the following constructions:

-- permutation group generated by elements,
-- direct_product_permgroups, which takes a list of permutation
             groups and returns their direct product.

JOKE:
    Q: What's hot, chunky, and acts on a polygon? A: Dihedral soup.
    Renteln, P. and Dundes, A. "Foolproof: A Sampling of Mathematical 
    Folk Humor." Notices Amer. Math. Soc. 52, 24--34, 2005.

AUTHOR:
    - David Joyner (2005-10-14): first version
    - David Joyner (2005-11-17)
    - William Stein (2005-11-26): rewrite to better wrap Gap
    - David Joyner (2005-12-21)
    - Stein and Joyner (2006-01-04): added conjugacy_class_representatives
    - David Joyner (2006-03): reorganization into subdirectory perm_gps;
                              added __contains__, has_element; fixed _cmp_;
                              added subgroup class+methods, PGL,PSL,PSp, PSU classes, 
    - David Joyner (2006-06): added PGU, functionality to SymmetricGroup, AlternatingGroup,
                                    direct_product_permgroups
    - David Joyner (2006-08): added degree, ramification_module_decomposition_modular_curve
                              and ramification_module_decomposition_hurwitz_curve
                              methods to PSL(2,q), MathieuGroup, is_isomorphic
    - Bobby Moretti (2006)-10): Added KleinFourGroup, fixed bug in DihedralGroup
    - David Joyner (2006-10): added is_subgroup (fixing a bug found by Kiran Kedlaya), 
                              is_solvable, normalizer, is_normal_subgroup, Suzuki
    - David Kohel (2007-02): fixed __contains__ to not enumerate group elements, 
                              following the convention for __call__
    - David Harvey, Mike Hansen, Nick Alexander, William Stein (2007-02,03,04,05): Various patches
    - Nathan Dunfield (2007-05): added orbits
    - David Joyner (2007-06): added subgroup method (suggested by David Kohel),
                              composition_series, lower_central_series, upper_central_series,
			      cayley_table, quotient_group, sylow_subgroup, is_cyclic,
                              homology, homology_part, cohomology, cohomology_part, 
                              poincare_series, molien_series, is_simple, is_monomial,
                              is_supersolvable, is_nilpotent, is_perfect, is_polycyclic,
                              is_elementary_abelian, is_pgroup, gens_small,
			      isomorphism_type_info_simple_group.
                              moved all the "named" groups to a new file.
    - Nick Alexander (2007-07): move is_isomorphic to isomorphism_to, add from_gap_list
    - William Stein (2007-07): put is_isomorphic back (and make it better)
                              
REFERENCES:
    Cameron, P., Permutation Groups. New York: Cambridge University Press, 1999.
    Wielandt, H., Finite Permutation Groups. New York: Academic Press, 1964.
    Dixon, J. and Mortimer, B., Permutation Groups, Springer-Verlag, Berlin/New York, 1996. 

NOTE:
    Though Suzuki groups are okay, Ree groups should *not* be wrapped as permutation groups - the 
    construction is too slow - unless (for small values or the parameter) they are
    made using explicit generators.
  
"""

#*****************************************************************************
#       Copyright (C) 2006 William Stein <wstein@gmail.com>
#                          David Joyner <wdjoyner@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************


import random

import sage.structure.element as element
import sage.groups.group as group

from sage.rings.all      import RationalField, Integer
from sage.interfaces.all import gap, is_GapElement, is_ExpectElement
import sage.structure.coerce as coerce
from sage.rings.finite_field import GF
from sage.rings.arith import factor
from sage.groups.abelian_gps.abelian_group import AbelianGroup
from sage.misc.functional import is_even, log
from sage.rings.rational_field import RationalField
from sage.matrix.matrix_space import MatrixSpace
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.fraction_field import FractionField
from sage.matrix.matrix_space import MatrixSpace

def gap_format(x):
    """
    Put a permutation in Gap format, as a string.
    """
    if isinstance(x,str): return x
    x = str(tuple(x)).replace(' ','')
    return x.replace('),(',')(').replace(',)',')')

def from_gap_list(G, src):
    r"""Convert a string giving a list of GAP permutations into a list of elements of G.

    EXAMPLES:
        sage: from sage.groups.perm_gps.permgroup import from_gap_list
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: L = from_gap_list(G, "[(1,2,3)(4,5), (3,4)]"); L
        [(1,2,3)(4,5), (3,4)]
        sage: L[0].parent() is G
        True
        sage: L[1].parent() is G
        True
    """
    # trim away the list constructs
    src = src.replace("[", "").replace("]", "")
    # cut out the individual elements
    srcs = src.split("),")
    for i in range(len(srcs[:-1])):
        srcs[i] = srcs[i] + ")"
    srcs = map(G, srcs)
    return srcs

def PermutationGroup(x, from_group=False, check=True):
    """
    Return the permutation group associated to $x$ (typically a list
    of generators).

    EXAMPLES:
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: G
        Permutation Group with generators [(1,2,3)(4,5), (3,4)]
    
    We can also make permutation groups from PARI groups:
        sage: H = pari('x^4 - 2*x^3 - 2*x + 1').polgalois()
        sage: G = PariGroup(H, 4); G            
        PARI group [8, -1, 3, "D(4)"] of degree 4
        sage: H = PermutationGroup(G); H          # requires optional database_gap
        Transitive group number 3 of degree 4
        sage: H.gens()                            # requires optional database_gap
        ((1,2,3,4), (1,3))
        
    EXAMPLES:
    There is an underlying gap object that implements each permutation group.
    
        sage: G = PermutationGroup([[(1,2,3,4)]])
        sage: G._gap_()
        Group([ (1,2,3,4) ])
        sage: gap(G)
        Group([ (1,2,3,4) ])
        sage: gap(G) is G._gap_()
        True
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: G._gap_().DerivedSeries()   # output somewhat random
        [ Group([ (1,2,3)(4,5), (3,4) ]), Group([ (1,5)(3,4), (1,5)(2,4), (1,4,5) ]) ]
    """
    if not is_ExpectElement(x) and hasattr(x, '_permgroup_'):
        return x._permgroup_()
    return PermutationGroup_generic(x, from_group, check)
    

class PermutationGroup_generic(group.FiniteGroup):
    """
    EXAMPLES:
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: G
        Permutation Group with generators [(1,2,3)(4,5), (3,4)]
        sage: G.center()
        Permutation Group with generators [()]
        sage: G.group_id()          # requires optional database_gap
        [120, 34]
        sage: n = G.order(); n
        120
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: loads(G.dumps()) == G
        True
    """
    def __init__(self, gens, from_group = False, check=True):
        if from_group and isinstance(gens, str):
            self.__gap = gens
            self.gens()  # so will check that group can be defined in GAP (e.g., no missing packages, etc.)
            return
        if is_GapElement(gens):
            if from_group:
                # the variable gens is actually a Gap group or string
                # representation of one.
                self.__gap = str(gens)
            else:
                # gens is a Gap object that represents a list of generators for a group
                self.__gap = 'Group(%s)'%gens
            self.gens() # so will check that group can be defined in GAP (e.g., no missing packages, etc.)
            return

        if check:
            if isinstance(gens, tuple):
                gens = list(gens)
            elif not isinstance(gens, list):
                raise TypeError, "gens must be a tuple or list"
            gens = [gap_format(x) for x in gens]
            
        cmd = 'Group(%s)'%gens
        cmd = cmd.replace("'","")  # get rid of quotes
        self.__gap = cmd
        self.gens()

    def _gap_init_(self):
        return self.__gap

    def _magma_init_(self):
        g = str(self.gens())[1:-1]
        return 'PermutationGroup<%s | %s>'%(self.degree(), g)

    def __cmp__(self, right):
        """
        Compare self and right.

        The ordering is whatever it is in Gap.
        
        EXAMPLES:
            sage: G1 = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G2 = PermutationGroup([[(1,2,3),(4,5)]])
            sage: G1 > G2
            True
            sage: G1 < G2
            False
        """
        if not isinstance(right, PermutationGroup_generic):
            return -1
        return right._gap_().__cmp__(self._gap_())
        

    def __call__(self, x):
        """
        Coerce x into this permutation group.

        The input can be either a string that defines a permutation in
        cycle notation, a permutation group element, a list of
        integers that gives the permutation as a mapping, a list of
        tuples, or the integer 1.

        EXAMPLES:
        We illustrate each way to make a permutation in S4:
            sage: G = SymmetricGroup(4)
            sage: G((1,2,3,4))
            (1,2,3,4)
            sage: G([(1,2),(3,4)])
            (1,2)(3,4)
            sage: G('(1,2)(3,4)')
            (1,2)(3,4)
            sage: G([1,2,4,3])
            (3,4)
            sage: G([2,3,4,1])
            (1,2,3,4)
            sage: G(G((1,2,3,4)))
            (1,2,3,4)
            sage: G(1)
            ()            

        Some more examples:
            sage: G = PermutationGroup([(1,2,3,4)])
            sage: G([(1,3), (2,4)])
            (1,3)(2,4)
            sage: G(G.0^3)
            (1,4,3,2)
            sage: G(1)
            ()
            sage: G((1,4,3,2))
            (1,4,3,2)
            sage: G([(1,2)])
            Traceback (most recent call last):
            ...
            TypeError: permutation (1,2) not in Permutation Group with generators [(1,2,3,4)]
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        if isinstance(x, PermutationGroupElement):
            if x.parent() is self:
                return x
            else:
                return PermutationGroupElement(x._gap_(), self, check = True)
        elif isinstance(x, (list, str)):
            if isinstance(x, list) and len(x) > 0 and not isinstance(x[0], tuple):
                # todo: This is ok, but is certainly not "industry strength" fast
                # compared to what is possible.
                x = gap.eval('PermList(%s)'%x)
            return PermutationGroupElement(x, self, check = True)
        elif isinstance(x, tuple):
            return PermutationGroupElement([x], self, check = True)
        elif isinstance(x, (int, long, Integer)) and x == 1:
            return self.identity()
        else:
            raise TypeError, "unable to coerce %s to permutation in %s"%(x, self)

    def _coerce_impl(self, x):
        r"""
        Implicit coercion of x into self.
        
        EXAMPLES:
        We illustrate some arithmetic that involves implicit coercion
        of elements in different permutation groups.
        
            sage: g1 = PermutationGroupElement([(1,2),(3,4,5)])
            sage: g1.parent()
            Symmetric group of order 5! as a permutation group
            sage: g2 = PermutationGroupElement([(1,2)])
            sage: g2.parent()
            Symmetric group of order 2! as a permutation group
            sage: g1*g2
            (3,4,5)
            sage: g2*g2
            ()
            sage: g2*g1
            (3,4,5)

        We try to implicitly coerce in a non-permutation, which raises
        a TypeError:

           sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])
           sage: G._coerce_impl(1)
           Traceback (most recent call last):
           ...
           TypeError: no implicit coercion of element into permutation group
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        if isinstance(x, PermutationGroupElement):
            if x.parent() is self:
                return x
            elif x.parent().degree() <= self.degree() and x._gap_() in self._gap_():
                return PermutationGroupElement(x._gap_(), self, check = False)
        raise TypeError, "no implicit coercion of element into permutation group"

    def list(self):
        """
        Return list of all elements of this group.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])
            sage: G.list()
            [(), (3,4), (2,3), (2,3,4), (2,4,3), (2,4), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4), (1,2,4,3), (1,2,4), (1,3,2), (1,3,4,2), (1,3), (1,3,4), (1,3)(2,4), (1,3,2,4), (1,4,3,2), (1,4,2), (1,4,3), (1,4), (1,4,2,3), (1,4)(2,3)]
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        X = self._gap_().Elements()
        n = X.Length()
        return [PermutationGroupElement(X[i], self, check = False)
                            for i in range(1,n+1)]

    def __contains__(self, item):
        """
        Returns boolean value of "item in self"

        EXAMPLES:
            sage: G = SymmetricGroup(16)
	    sage: g = G.gen(0)
	    sage: h = G.gen(1)
	    sage: g^7*h*g*h in G
	    True
	    sage: G = SymmetricGroup(4)
	    sage: g = G((1,2,3,4))
	    sage: h = G((1,2))
            sage: H = PermutationGroup([[(1,2,3,4)], [(1,2),(3,4)]])
	    sage: g in H
	    True
	    sage: h in H
	    False
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        if isinstance(item, PermutationGroupElement):
            if not item.parent() is self:
                try: 
		    item = PermutationGroupElement(item._gap_(), self, check = True)
		except:
		    return False
 	    return True
        elif isinstance(item, (list, str)):
            if isinstance(item, list) and len(item) > 0 and not isinstance(item[0], tuple):
                item = gap.eval('PermList(%s)'%item)
            try: 
	        item = PermutationGroupElement(item, self, check = True)
	    except:
	        return False
            return True
        elif isinstance(item, tuple):
            if isinstance(item, list) and len(item) > 0 and not isinstance(item[0], tuple):
                item = gap.eval('PermList(%s)'%item)
            try: 
	        item = PermutationGroupElement(item, self, check = True)
	    except:
	        return False
            return True
        elif isinstance(item, (int, long, Integer)) and item == 1:
            return True
        return False

    def has_element(self,item):
        """
        Returns boolean value of "item in self" -- however *ignores* parentage.

        EXAMPLES:
            sage: G = CyclicPermutationGroup(4)
	    sage: gens = G.gens()
	    sage: H = DihedralGroup(4)
	    sage: g = G([(1,2,3,4)]); g
            (1,2,3,4)
	    sage: G.has_element(g)
            True
	    sage: h = H([(1,2),(3,4)]); h
            (1,2)(3,4)
	    sage: G.has_element(h)
            False

        """
        L = [str(x) for x in self.list()]
        return (str(item) in L)

    def __iter__(self):
        """
        Return an iterator over the elements of this group.
        
        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3)], [(1,2)]])
            sage: [a for a in G]
            [(), (2,3), (1,2), (1,2,3), (1,3,2), (1,3)]
        """
        for g in self.list():
            yield g

    def gens(self):
        """
        Return tuple of generators of this group.  These need not be
        minimal, as they are the generators used in defining this
        group.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3)], [(1,2)]])
            sage: G.gens()
            ((1,2,3), (1,2))

        Note that the generators need not be minimal.
            sage: G = PermutationGroup([[(1,2)], [(1,2)]])
            sage: G.gens()
            ((1,2), (1,2))
            
            sage: G = PermutationGroup([[(1,2,3,4), (5,6)], [(1,2)]])
            sage: g = G.gens()
            sage: g[0]
            (1,2,3,4)(5,6)
            sage: g[1]
            (1,2)
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        try:
            return self.__gens
        except AttributeError:
            try:
                gens = self._gap_().GeneratorsOfGroup()
            except TypeError, s:
                raise RuntimeError, "(It might be necessary to install the database_gap optional SAGE package, if you haven't already.)\n%s"%s
            self.__gens = tuple([PermutationGroupElement(gens[n],
                                    self, check = False) for n in \
                                 range(1, Integer(gens.Length())+1)])
            return self.__gens

    def gens_small(self):
        """
        Returns a generating set of G which has few elements. As neither
        irredundancy, nor minimal length is proven, it is fast.

        EXAMPLES:
            sage: R = "(25,27,32,30)(26,29,31,28)( 3,38,43,19)( 5,36,45,21)( 8,33,48,24)" ## R = right
            sage: U = "( 1, 3, 8, 6)( 2, 5, 7, 4)( 9,33,25,17)(10,34,26,18)(11,35,27,19)" ## U = top
            sage: L = "( 9,11,16,14)(10,13,15,12)( 1,17,41,40)( 4,20,44,37)( 6,22,46,35)" ## L = left
            sage: F = "(17,19,24,22)(18,21,23,20)( 6,25,43,16)( 7,28,42,13)( 8,30,41,11)" ## F = front
            sage: B = "(33,35,40,38)(34,37,39,36)( 3, 9,46,32)( 2,12,47,29)( 1,14,48,27)" ## B = back or rear
            sage: D = "(41,43,48,46)(42,45,47,44)(14,22,30,38)(15,23,31,39)(16,24,32,40)" ## D = down or bottom
            sage: G = PermutationGroup([R,L,U,F,B,D])
            sage: len(G.gens_small())
            2
        """
        return self._gap_().SmallGeneratingSet()

    def gen(self, i):
        return self.gens()[Integer(i)]

    def cayley_table(self, names="x"):
        """
        Returns the multiplication table, or Cayley table, of the
        finite group G in the form of a matrix with symbolic coefficients.
        This function is useful for learning, teaching, and exploring
        elementary group theory. Of course, G must be a group of low order.

        As the last line below illustrates, the ordering used here in the first
        row is the same as in G.list().
    
        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)', '(2,3)'])
            sage: G.cayley_table()
            [x0 x1 x2 x3 x4 x5]
            [x1 x0 x3 x2 x5 x4]
            [x2 x4 x0 x5 x1 x3]
            [x3 x5 x1 x4 x0 x2]
            [x4 x2 x5 x0 x3 x1]
            [x5 x3 x4 x1 x2 x0]
            sage: G.list()[3]*G.list()[3] == G.list()[4]
            True
            sage: G.cayley_table("y")
            [y0 y1 y2 y3 y4 y5]
            [y1 y0 y3 y2 y5 y4]
            [y2 y4 y0 y5 y1 y3]
            [y3 y5 y1 y4 y0 y2]
            [y4 y2 y5 y0 y3 y1]
            [y5 y3 y4 y1 y2 y0]
            sage: G.cayley_table(names="abcdef")
            [a b c d e f]
            [b a d c f e]
            [c e a f b d]
            [d f b e a c]
            [e c f a d b]
            [f d e b c a]

        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        G = self
        n = G.order()
        phi = G._gap_().RegularActionHomomorphism()
        gens = phi.Image().GeneratorsOfGroup()
        N = Integer(gens.Length())
        nm = gens.name()
        gens = [PermutationGroupElement(gap.eval("%s[%s];"%(nm, i))) for i in range(1,N+1)]
        H = PermutationGroup(gens)
        nH = H.order()
        R,vars = PolynomialRing(RationalField(),names,nH).objgens()
        multiplication_table_G = sum([(H.list()[i]).matrix()*vars[i] for i in range(nH)])
        MT = multiplication_table_G.rows()
        MT.sort()
        MT.reverse()
        MS = MatrixSpace(R,n,n)
        return MS(MT)

    multiplication_table = cayley_table
    
    def identity(self):
        """
        Return the identity element of this group.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)]])
            sage: e = G.identity()
            sage: e
            ()
            sage: g = G.gen(0)
            sage: g*e
            (1,2,3)(4,5)
            sage: e*g
            (1,2,3)(4,5)
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        return PermutationGroupElement('()', self, check=True)

    def degree(self):
        """
        Synonym for largest_moved_point().

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.degree()
            5
        """
        return self.largest_moved_point()
    
    def exponent(self):
        """
         Computes the exponent of the group. The exponent $e$ of a group $G$ is the lcm of 
         the orders of its elements, that is, $e$ is the smallest integer such that $g^e=1$ for all 
         $g \in G$.

         EXAMPLES:
             sage: G = AlternatingGroup(4)
             sage: G.exponent()
             6
        """
        return Integer(self._gap_().Exponent())

    def largest_moved_point(self):
        """
        Return the largest point moved by a permutation in this group.
        
        EXAMPLES:
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: G.largest_moved_point()
            4
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
            sage: G.largest_moved_point()
            10
        """
        try:
            return self.__largest_moved_point
        except AttributeError:
            n = Integer(self._gap_().LargestMovedPoint())
        self.__largest_moved_point = n
        return n

    def smallest_moved_point(self):
        """
        Return the smallest point moved by a permutation in this group.
        
        EXAMPLES:
            sage: G = PermutationGroup([[(3,4)], [(2,3,4)]])
            sage: G.smallest_moved_point()
            2
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
            sage: G.smallest_moved_point()
            1
        """
        try:
            return self.__smallest_moved_point
        except AttributeError:
            n = Integer(self._gap_().SmallestMovedPoint())
        self.__smallest_moved_point = n
        return n

    def orbits(self):
        """
        Returns the orbits of [1,2,...,degree] under the group action.

        EXAMPLES:
           sage: G = PermutationGroup([ [(3,4)], [(1,3)] ]) 
           sage: G.orbits()
           [[1, 3, 4], [2]]
           sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
           sage: G.orbits()
           [[1, 2, 3, 4, 10], [5], [6], [7], [8], [9]]

        The answer is cached:
           sage: G.orbits() is G.orbits()
           True           

        AUTHOR:
             -- Nathan Dunfield
        """
        try:
            return self.__orbits
        except AttributeError:
            O = self._gap_().Orbits("[1..%d]" % self.largest_moved_point()).sage()
            self.__orbits = O
            return O
    
    def _repr_(self):
        G = self.gens()
        return "Permutation Group with generators %s"%list(self.gens())

    def _latex_(self):
        return '\\langle ' + \
               ', '.join([x._latex_() for x in self.gens()]) + ' \\rangle'

    def order(self):
        """
        Return the number of elements of this group.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.order()
            12
        """
        return Integer(self._gap_().Size())

    def random_element(self):
        """
        Return a random element of this group.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.random_element()         ## random output
            (1, 3)(4, 5)
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        return PermutationGroupElement(self._gap_().Random(),
                                       self, check=False)

    def group_id(self):
        """
        Return the ID code of this group, which is a list of two
        integers. Requires "optional" database_gap-4.4.x package.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.group_id()    # requires optional database_gap-4.4.6 package
            [12, 4]
        """
        return [Integer(n) for n in eval(str(self._gap_().IdGroup()))]

    def id(self):
        """
        Same as self.group_id()
        """
        return self.group_id()

    def center(self):
        """
        Return the subgroup of elements of that commute with
        every element of this group.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3,4)]])
            sage: G.center()
            Permutation Group with generators [(1,2,3,4)]
            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])
            sage: G.center()
            Permutation Group with generators [()]
        """
        C = self._gap_().Center()
        return PermutationGroup(C, from_group = True)

    def direct_product(self,other,maps=True):
        """
        Wraps GAP's DirectProduct, Embedding, and Projection. 

        SAGE calls GAP's DirectProduct, which chooses an efficient representation
        for the direct product. The direct product of permutation groups will
        be a permutation group again. For a direct product D, the GAP
        operation Embedding(D,i) returns the homomorphism embedding the 
        i-th factor into D. The GAP operation Projection(D,i) gives the projection
        of D onto the i-th factor.

        INPUT:
            self, other -- permutation groups
         
        This method returns a 5-tuple - a permutation groups and 4 morphisms. 

        OUTPUT:
            D     -- a direct product of the inputs, returned as a permutation group as well
            iota1 -- an embedding of self into D
            iota2 -- an embedding of other into D
            pr1   -- the projection of D onto self  (giving a splitting 1 -> other -> D ->> self -> 1)
            pr2   -- the projection of D onto other (giving a splitting 1 -> self -> D ->> other -> 1)

        EXAMPLES:
            sage: G = CyclicPermutationGroup(4)
            sage: D = G.direct_product(G,False)
            sage: D
            Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            sage: D,iota1,iota2,pr1,pr2 = G.direct_product(G)
            sage: D; iota1; iota2; pr1; pr2
            Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            Homomorphism : Cyclic group of order 4 as a permutation group --> Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            Homomorphism : Cyclic group of order 4 as a permutation group --> Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            Homomorphism : Permutation Group with generators [(1,2,3,4), (5,6,7,8)] --> Cyclic group of order 4 as a permutation group
            Homomorphism : Permutation Group with generators [(1,2,3,4), (5,6,7,8)] --> Cyclic group of order 4 as a permutation group

            sage: g=D([(1,3),(2,4)]); g
            (1,3)(2,4)
            sage: d=D([(1,4,3,2),(5,7),(6,8)]); d
            (1,4,3,2)(5,7)(6,8)
            sage: iota1(g); iota2(g); pr1(d); pr2(d)
            (1,3)(2,4)
            (5,7)(6,8)
            (1,4,3,2)
            (1,3)(2,4)

        """
        from sage.groups.perm_gps.permgroup_morphism import PermutationGroupMorphism_from_gap
        G1 = self._gap_init_()
        G2 = other._gap_init_()
        cmd1 = "G:=DirectProduct("+G1+","+G2+")"
        cmd2 = "iota1:=Embedding(G,1)"
        cmd3 = "iota2:=Embedding(G,2)"
        cmd4 = "pr1:=Projection(G,1)"
        cmd5 = "pr2:=Projection(G,2)"
        if not(maps):
            return PermutationGroup(gap.eval(cmd1), from_group = True)
        else:
            D = PermutationGroup_generic(gap.eval(cmd1), from_group = True)
            iota1 = PermutationGroupMorphism_from_gap(self,D, cmd2, "iota1")
            iota2 = PermutationGroupMorphism_from_gap(other,D, cmd3, "iota2")
            pr1 = PermutationGroupMorphism_from_gap(D,self, cmd4, "pr1")
            pr2 = PermutationGroupMorphism_from_gap(D,other, cmd5, "pr2")
            return D,iota1,iota2,pr1,pr2

    def subgroup(self,gens):
        """
        Wraps the PermutationGroup_subgroup constructor. The argument gens is 
        a list of elements of self.

        EXAMPLES:
            sage: G = PermutationGroup([(1,2,3),(3,4,5)])
            sage: g = G((1,2,3))
            sage: G.subgroup([g])
            Subgroup of Permutation Group with generators [(1,2,3), (3,4,5)] generated by [(1,2,3)]

        """
        return PermutationGroup_subgroup(self,gens)

    def sylow_subgroup(self, p):
        """
        Returns a Sylow p-subgroups of the finite group G, where p is
        a prime. This is a p-subgroup of G whose index in G is coprime to p.
        Wraps the GAP function SylowSubgroup.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)', '(2,3)'])
            sage: G.sylow_subgroup(2)
            Permutation Group with generators [(2,3)]
            sage: G.sylow_subgroup(5)
            Permutation Group with generators [()]

        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        G = self
        gap.eval("G := %s"%G._gap_init_())
        gap.eval("Ssgp := SylowSubgroup(G, %s);"%p)
        gap.eval("gens := GeneratorsOfGroup( Ssgp );")
        N = Integer(gap.eval("N := Length(gens);"))
        if N>0:
            gens = [PermutationGroupElement(gap.eval("gens[%s];"%j)) for j in range(1,N+1)]
            H = PermutationGroup(gens)
        else:
            H = PermutationGroup([()])
        return H

    def quotient_group(self, N):
        """
        Returns the quotient group permgp/N, where N is a normal subgroup. Wraps the
        GAP operator "/".

        EXAMPLES:
            sage: G = PermutationGroup([(1,2,3), (2,3)])
            sage: N = PermutationGroup([(1,2,3)])
            sage: G.quotient_group(N)
            Permutation Group with generators [(1,2)]

        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        G = self
        gap.eval("G := %s"%G._gap_().name())
        gap.eval("N := %s"%N._gap_().name())
        gap.eval("Q := G/N;")
        gap.eval("phi := RegularActionHomomorphism( Q );")
        gap.eval("gens := GeneratorsOfGroup( Image( phi ));")
        N = Integer(gap.eval("N := Length(gens);"))
        if N>0:
            gens = [PermutationGroupElement(gap.eval("gens[%s];"%i)) for i in range(1,N+1)]
            Q = PermutationGroup(gens)
            return Q
        else:
            return PermutationGroup([()])

    def cohomology(self, n, p = 0):
        """
        Computes the group cohomology H_n(G, F), where F = Z if p=0
        and F = Z/pZ if p >0 is a prime. Wraps HAP's GroupHomology
        function, written by Graham Ellis.

        REQUIRES:
            GAP package HAP (in gap_packages-*.spkg).

        EXAMPLES:
            sage: G = SymmetricGroup(3)
            sage: G.cohomology(5)                              # requires optional gap_packages
            Trivial Abelian Group
            sage: G.cohomology(5,2)                            # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C2
            sage: G.homology(5,3)                              # requires optional gap_packages
            Trivial Abelian Group
            sage: G.homology(5,4)                              # requires optional gap_packages
            Traceback (most recent call last):
            ...
            ValueError: p must be 0 or prime

        This computes $H^4(S_3,ZZ)$, $H^4(S_3,ZZ/2ZZ)$, resp. 

        AUTHORS:
            David Joyner and Graham Ellis

        REFERENCES:
            G. Ellis, "Computing group resolutions", J. Symbolic Computation. Vol.38, (2004)1077--1118
            (Available at \code{http://hamilton.nuigalway.ie/}.
            D. Joyner, "A primer on computational group homology and cohomology",
            \code{http://front.math.ucdavis.edu/0706.0549}

        """
        gap.eval('RequirePackage("HAP")')
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            L = eval(gap.eval("GroupCohomology(%s,%s)"%(GG,n)))
        else:
	    L = eval(gap.eval("GroupCohomology(%s,%s,%s)"%(GG,n,p)))
        return AbelianGroup(len(L),L)

    def cohomology_part(self, n, p = 0):
        """
        Computes the p-part of the group cohomology $H^n(G, F)$, where $F = Z$ if $p=0$
        and $F = Z/pZ$ if $p >0$ is a prime. Wraps HAP's Homology function, written by 
        Graham Ellis, applied to the $p$-Sylow subgroup of $G$.

        REQUIRES:
            GAP package HAP (in gap_packages-*.spkg).

        EXAMPLES:  
            sage: G = SymmetricGroup(5)
            sage: G.cohomology_part(7,2)                   # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C2
            sage: G = SymmetricGroup(3)
            sage: G.cohomology_part(2,3) 
            Multiplicative Abelian Group isomorphic to C3

        AUTHORS:
            David Joyner and Graham Ellis
        """
        gap.eval('RequirePackage("HAP")')
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            H = AbelianGroup(1,[1])
        else:
            gap.eval("S := SylowSubgroup(%s,%s)"%(GG,p))
            gap.eval("R:=ResolutionFiniteGroup(S,%s)"%(n+1))
            gap.eval("HR:=HomToIntegers(R)")
	    L = eval(gap.eval("Cohomology(HR,%s)"%n))
        return AbelianGroup(len(L),L)

    def homology(self, n, p = 0):
        r"""
        Computes the group homology $H_n(G, F)$, where $F = Z$ if $p=0$
        and $F = Z/pZ$ if $p >0$ is a prime. Wraps HAP's GroupHomology
        function, written by Graham Ellis.

        REQUIRES:
            GAP package HAP (in gap_packages-*.spkg).

        AUTHORS:
            David Joyner and Graham Ellis

        The example below computes $H_7(S_5,ZZ)$, $H_7(S_5,ZZ/2ZZ)$, $H_7(S_5,ZZ/3ZZ)$, and $H_7(S_5,ZZ/5ZZ)$, 
        resp. To compute the $2$-part of $H_7(S_5,ZZ)$, use the \code{homology_part} function.

        EXAMPLES:
            sage: G = SymmetricGroup(5)
            sage: G.homology(7)                              # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C3 x C4 x C5
            sage: G.homology(7,2)                              # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C2 x C2 x C2
            sage: G.homology(7,3)                              # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C3
            sage: G.homology(7,5)                              # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C5
            
        REFERENCES:
            G. Ellis, "Computing group resolutions", J. Symbolic Computation. Vol.38, (2004)1077--1118
            (Available at \code{http://hamilton.nuigalway.ie/}.
            D. Joyner, "A primer on computational group homology and cohomology",
            \code{http://front.math.ucdavis.edu/0706.0549}

        """
        gap.eval('RequirePackage("HAP")')
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            L = eval(gap.eval("GroupHomology(%s,%s)"%(GG,n)))
        else:
	    L = eval(gap.eval("GroupHomology(%s,%s,%s)"%(GG,n,p)))
        return AbelianGroup(len(L),L)

    def homology_part(self, n, p = 0):
        r"""
        Computes the $p$-part of the group homology $H_n(G, F)$, where $F = Z$ if $p=0$
        and $F = Z/pZ$ if $p >0$ is a prime. Wraps HAP's Homology function, written by 
        Graham Ellis, applied to the $p$-Sylow subgroup of $G$.

        REQUIRES:
            GAP package HAP (in gap_packages-*.spkg).

        EXAMPLES:  
            sage: G = SymmetricGroup(5)
            sage: G.homology_part(7,2)                              # requires optional gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C2 x C2 x C4

        AUTHORS:
            David Joyner and Graham Ellis
        """
        gap.eval('RequirePackage("HAP")')
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            H = AbelianGroup(1,[1])
        else:
            gap.eval("S := SylowSubgroup(%s,%s)"%(GG,p))
            gap.eval("R:=ResolutionFiniteGroup(S,%s)"%(n+1))
            gap.eval("TR:=TensorWithIntegers(R);")
	    L = eval(gap.eval("Homology(TR,%s)"%n))
        return AbelianGroup(len(L),L)

    def poincare_series(self, p=2, n=10):
        """
        Returns the Poincare series of G mod p (p must be a prime), for n>1 
        large. In other words, if you input a finite group G, a prime p, 
        and a positive integer n, it returns a quotient of polynomials 
        f(x)=P(x)/Q(x) whose coefficient of $x^k$ equals the rank of the 
        vector space $H_k(G,ZZ/pZZ)$, for all k in the range $1\leq k \leq n$. 
        
        REQUIRES:
            GAP package HAP (in gap_packages-*.spkg).

        EXAMPLES: 
            sage: G = SymmetricGroup(5)
            sage: G.poincare_series(2,10)                              # requires optional gap_packages
            (x^2 + 1)/(x^4 - x^3 - x + 1)
            sage: G = SymmetricGroup(3)
            sage: G.poincare_series(2,10)                              # requires optional gap_packages
            1/(-x + 1)

        AUTHORS:
            David Joyner and Graham Ellis
        """
        gap.eval('RequirePackage("HAP")')
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        ff = gap.eval("ff := PoincareSeriesPrimePart(%s,%s,%s)"%(GG,p,n))
        R = PolynomialRing(RationalField(),"x")
	x = R.gen()
        nn = gap.eval("NumeratorOfRationalFunction(ff)")
        dd = gap.eval("DenominatorOfRationalFunction(ff)")
        FF = FractionField(R)
        return FF(nn)/FF(dd)

    def molien_series(self):
        r"""
        Returns the Moien series of a transtive permutation group.
        The function
        $$
        M(x) = (1/|G|)\sum_{g\in G} det(1-x*g)^(-1)
        $$
        is sometimes called the "Molien series" of G.
        GAP's \code{MolienSeries} is associated to a character of a group G.
        How are these related? A group G, given as a permutation 
        group on n points, has a "natural" representation of 
        dimension n, given by permutation matrices. The Molien series 
        of G is the one associated to that permutation representation of 
        G using the above formula. Character values then count fixed 
        points of the corresponding permutations. 
        
        EXAMPLES:
            sage: G = SymmetricGroup(5)
            sage: G.molien_series()                              # requires optional gap_packages
            1/(-x^15 + x^14 + x^13 - x^10 - x^9 - x^8 + x^7 + x^6 + x^5 - x^2 - x + 1)
            sage: G = SymmetricGroup(3)
            sage: G.molien_series()                              # requires optional gap_packages
            1/(-x^6 + x^5 + x^4 - x^2 - x + 1)

        """
        G = self
        GG = G._gap_init_()
        gap.eval("pi := NaturalCharacter( %s )"%GG)
        gap.eval("cc := ConstituentsOfCharacter( pi )")
        M = gap.eval("M := MolienSeries(Sum(cc))")
        R = PolynomialRing(RationalField(),"x")
	x = R.gen()
        nn = gap.eval("NumeratorOfRationalFunction(M)")
        dd = gap.eval("DenominatorOfRationalFunction(M)")
        FF = FractionField(R)
        return FF(nn.replace("_1",""))/FF(dd.replace("_1",""))
    
    def character_table(self):
        r"""
        Returns the matrix of values of the irreducible characters of
        a permutation group $G$ at the conjugacy classes of $G$. The
        columns represent the the conjugacy classes of $G$ and the
        rows represent the different irreducible characters in the
        ordering given by GAP.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3)]])
            sage: G.order()
            12
            sage: G.character_table()
            [         1          1          1          1]
            [         1          1 -zeta3 - 1      zeta3]
            [         1          1      zeta3 -zeta3 - 1]
            [         3         -1          0          0]
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3)]])
            sage: CT = gap(G).CharacterTable()

        Type print gap.eval("Display(%s)"%CT.name()) to display this nicely.

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: G.order()
            8
            sage: G.character_table()
            [ 1  1  1  1  1]
            [ 1 -1 -1  1  1]
            [ 1 -1  1 -1  1]
            [ 1  1 -1 -1  1]
            [ 2  0  0  0 -2]
            sage: CT = gap(G).CharacterTable()

        Again, type print gap.eval("Display(%s)"%CT.name()) to display this.
        
            sage: SymmetricGroup(2).character_table()
            [ 1 -1]
            [ 1  1]
            sage: SymmetricGroup(3).character_table()
            [ 1 -1  1]
            [ 2  0 -1]
            [ 1  1  1]
            sage: SymmetricGroup(5).character_table()
            [ 1 -1  1  1 -1 -1  1]
            [ 4 -2  0  1  1  0 -1]
            [ 5 -1  1 -1 -1  1  0]
            [ 6  0 -2  0  0  0  1]
            [ 5  1  1 -1  1 -1  0]
            [ 4  2  0  1 -1  0 -1]
            [ 1  1  1  1  1  1  1]
            sage: list(AlternatingGroup(6).character_table())
            [(1, 1, 1, 1, 1, 1, 1), (5, 1, 2, -1, -1, 0, 0), (5, 1, -1, 2, -1, 0, 0), (8, 0, -1, -1, 0, zeta5^3 + zeta5^2 + 1, -zeta5^3 - zeta5^2), (8, 0, -1, -1, 0, -zeta5^3 - zeta5^2, zeta5^3 + zeta5^2 + 1), (9, 1, 0, 0, 1, -1, -1), (10, -2, 1, 1, 0, 0, 0)]

        Suppose that you have a class function $f(g)$ on $G$ and you
        know the values $v_1, ..., v_n$ on the conjugacy class
        elements in \code{conjugacy_classes_representatives(G)} =
        $[g_1, \ldots, g_n]$.  Since the irreducible characters
        $\rho_1, \ldots, \rho_n$ of $G$ form an $E$-basis of the space
        of all class functions ($E$ a ``sufficiently large''
        cyclotomic field), such a class function is a linear
        combination of these basis elements, $f = c_1\rho_1 + \cdots +
        c_n\rho_n$. To find the coefficients $c_i$, you simply solve
        the linear system \code{character_table_values(G)}*$[v_1, ...,
        v_n] = [c_1, ..., c_n]$,
        where $[v_1, ...,v_n]$ = \code{character_table_values(G)}$^{-1}[c_1, ...,c_n]$.

        AUTHORS:
            - David Joyner and William Stein (2006-01-04)
        """
        G    = self._gap_()
        cl   = G.ConjugacyClasses()
        n    = Integer(cl.Length())
        irrG = G.Irr()
        ct   = [[irrG[i+1,j+1] for j in range(n)] for i in range(n)]

        from sage.rings.all import CyclotomicField
        e = irrG.Flat().Conductor()
        K = CyclotomicField(e)
        ct = [[K(x) for x in v] for v in ct]

        # Finally return the result as a matrix.
        from sage.matrix.all import MatrixSpace
        MS = MatrixSpace(K,n)
        return MS(ct)

    def conjugacy_classes_representatives(self):
        """ 
        Returns a complete list of representatives of conjugacy classes
        in a permutation group G. The ordering is that given by GAP.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: cl = G.conjugacy_classes_representatives(); cl
            [(), (2,4), (1,2)(3,4), (1,2,3,4), (1,3)(2,4)]
            sage: cl[3] in G
            True

            sage: G = SymmetricGroup(5)
            sage: G.conjugacy_classes_representatives ()
            [(), (1,2), (1,2)(3,4), (1,2,3), (1,2,3)(4,5), (1,2,3,4), (1,2,3,4,5)]
            

        AUTHOR: David Joyner and William Stein (2006-01-04)
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        cl = self._gap_().ConjugacyClasses()
        n = Integer(cl.Length())
        L = gap("List([1..Length(%s)], i->Representative(%s[i]))"%(
            cl.name(),  cl.name()))
        return [PermutationGroupElement(L[i], self, check=False) \
                for i in range(1,n+1)]

    def conjugacy_classes_subgroups(self):
        """ 
        Returns a complete list of representatives of conjugacy classes
        of subgroups in a permutation group G. The ordering is that given by GAP.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: cl = G.conjugacy_classes_subgroups()
            sage: cl[3] 
            Group([ (2,4) ])

            sage: G = SymmetricGroup(3)
            sage: G.conjugacy_classes_subgroups()
            [Group(()), Group([ (2,3) ]), Group([ (1,2,3) ]), Group([ (1,3,2), (1,2) ])]

        AUTHOR: David Joyner (2006-10)
        """
        from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
        G = self._gap_()
        cl = G.ConjugacyClassesSubgroups()
        n = Integer(cl.Length())
        L = gap("List([1..Length(%s)], i->Representative(%s[i]))"%(
            cl.name(),  cl.name()))
        return [PermutationGroupElement(L[i], self, check=False) \
                for i in range(1,n+1)]
		
    def normalizer(self,g):
        """
        Returns the normalizer of g in self.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: g = G.random_element()
            sage: G.normalizer(g)  ## random output
            Group([ (2,4), (1,3) ])
            sage: g = G([(1,2,3,4)])
            sage: G.normalizer(g)
            Group([ (1,2,3,4), (1,3)(2,4), (2,4) ])

        """
        N = self._gap_().Normalizer(str(g))
        return N

    def isomorphism_type_info_simple_group(self):
        """
        Is the group is simple, then this returns the name of the group.

        EXAMPLES:
            sage: G = CyclicPermutationGroup(5)
            sage: G.isomorphism_type_info_simple_group()
            rec( series := "Z", parameter := 5, name := "Z(5)" )

        """
        if self.is_simple():
            info = self._gap_().IsomorphismTypeInfoFiniteSimpleGroup()
            return info
        else:
            return TypeError, "Group must be simple."
        
    ######################  Boolean tests #####################
    
    def is_abelian(self):
        """
        Return True if this group is abelian.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_abelian()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_abelian()
            True
        """
        t = self._gap_().IsAbelian()
        return t.bool()
        
    def is_commutative(self):
        """
        Return True if this group is commutative.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_commutative()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_commutative()
            True
        """
        return self.is_abelian()

    def is_cyclic(self):
        """
        Return True if this group is cyclic.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_cyclic()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_cyclic()
            True
        """
        t = self._gap_().IsCyclic()
        return t.bool()

    def is_elementary_abelian(self):
        """
        Return True if this group is elementary abelian. An elementary abelian
        group is a finite Abelian group, where every nontrivial element has order p,
        where p is a prime.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_elementary_abelian()
            False
            sage: G = PermutationGroup(['(1,2,3)','(4,5,6)'])
            sage: G.is_elementary_abelian()
            True
        """
        t = self._gap_().IsElementaryAbelian()
        return t.bool()
    
    def isomorphism_to(self,right):
        """
        Return an isomorphism self to right if the groups are isomorphic, otherwise None.

        INPUT:
            self -- this group
            right -- a permutation group

        OUTPUT:
            None or a morphism of permutation groups.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: H = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.isomorphism_to(H) is None
            True
            sage: G = PermutationGroup([(1,2,3), (2,3)])
            sage: H = PermutationGroup([(1,2,4), (1,4)])
            sage: G.isomorphism_to(H) # random
            Homomorphism : Permutation Group with generators [(1,2,3), (2,3)] --> Permutation Group with generators [(1,2,4), (1,4)]
        """
        if not isinstance(right, PermutationGroup_generic):
            raise TypeError, "right must be a permutation group"
        G = self._gap_init_()
        H = right._gap_init_()
        gap.eval("x:=IsomorphismGroups( %s, %s )"%(G,H))
        s = gap.eval("x")
        if s == "fail":
            return None
        # slice and dice the GAP return to build a SAGE group homomorphism
        src, dst = s.split("->")
        # we eval to get things as lists
        srcs = from_gap_list(self, src)
        dsts = from_gap_list(right, dst)
        from permgroup_morphism import PermutationGroupMorphism_im_gens
        return PermutationGroupMorphism_im_gens(self, right, srcs, dsts)

    def is_isomorphic(self, right):
        """
        Return True if the groups are isomorphic. If mode="verbose" then
        an isomorphism is printed.

        INPUT:
            self -- this group
            right -- a permutation group
        OUTPUT:
            bool

        EXAMPLES:
            sage: v = ['(1,2,3)(4,5)', '(1,2,3,4,5)']
            sage: G = PermutationGroup(v)
            sage: H = PermutationGroup(['(1,2,3)(4,5)'])                                               
            sage: G.is_isomorphic(H)                                                                   
            False
            sage: G.is_isomorphic(G)
            True
            sage: G.is_isomorphic(PermutationGroup(list(reversed(v))))
            True
        """
        if not isinstance(right, PermutationGroup_generic):
            raise TypeError, "right must be a permutation group"
        G = self._gap_()
        H = right._gap_()
        return gap.eval("IsomorphismGroups( %s, %s )"%(G.name(),H.name())) != "fail"

    def is_monomial(self):
        """
        Returns True if the group is monomial. A finite group is monomial if every irreducible 
        complex character is induced from a linear character of a subgroup.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_monomial()
            True
        """
        ans = self._gap_().IsMonomialGroup()
        return ans.bool()

    def is_nilpotent(self):
        """
        Return True if this group is nilpotent.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_nilpotent()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_nilpotent()
            True
        """
        t = self._gap_().IsNilpotent()
        return t.bool()

    def is_normal(self,other):
        """
        Return True if the group self is a normal subgroup of other.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: H = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_normal(H)
            True
        """
        t = self._gap_().IsNormal(other._gap_())
        return t.bool()
    
    def is_perfect(self):
        """
        Return True if this group is perfect. A group is perfect if it equals its derived subgroup.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_perfect()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_perfect()
            False
        """
        t = self._gap_().IsPerfectGroup()
        return t.bool()

    def is_pgroup(self):
        """
        Returns True if the group is a p-group. A finite group is a p-group if
        its order is of the form $p^n$ for a prime integer p and a nonnegative integer n.  

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3,4,5)'])
            sage: G.is_pgroup()
            True
        """
        ans = self._gap_().IsPGroup()
        return ans.bool()

    def is_polycyclic(self):
        r"""
        Return True if this group is polycyclic. A group is polycyclic if it has a subnormal series 
        with cyclic factors. (For finite groups this is the same as if the group is solvable - see
        \code{is_solvable})].)

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_polycyclic()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_polycyclic()
            True
        """
        t = self._gap_().IsPolycyclicGroup()
        return t.bool()
    
    def is_simple(self):
        """
        Returns True if the group is simple. A group is simple if it has no proper normal
        subgroups.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_simple()
            False
        """
        ans = self._gap_().IsSimpleGroup()
        return ans.bool()

    def is_solvable(self):
        """
        Returns True if the group is solvable.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_solvable()
            True
        """
        ans = self._gap_().IsSolvableGroup()
        return ans.bool()
    
    def is_subgroup(self,other):
        """
        Returns true if self is a subgroup of other. 

        EXAMPLES:
            sage: G = AlternatingGroup(5)
            sage: H = SymmetricGroup(5)
            sage: G.is_subgroup(H)
            True
        """
        G = other
        gens = self.gens()
        for i in range(len(gens)):
            x = gens[i]
            if not (G.has_element(x)):
                return False
        return True
	
    def is_supersolvable(self):
        """
        Returns True if the group is supersolvable. A finite group is supersolvable if it has a 
        normal series with cyclic factors.

        EXAMPLES:
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_supersolvable()
            True

        """
        ans = self._gap_().IsSupersolvableGroup()
        return ans.bool()
    
    ############## Series ######################
    
    def composition_series(self):
        """
        Return the derived series of this group as a list of
        permutation groups.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.composition_series()        # somewhat random output
            [Permutation Group with generators [(1,2,3)(4,5), (3,4)],
             Permutation Group with generators [(1,5)(3,4), (1,5)(2,4), (1,3,5)],
             Permutation Group with generators [()]]

        """
        ans = []
        DS = self._gap_().CompositionSeries()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i], from_group = True))
        return ans

    def derived_series(self):
        """
        Return the derived series of this group as a list of
        permutation groups.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.derived_series()        # somewhat random output
            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], 
             Permutation Group with generators [(1,5)(3,4), (1,5)(2,4), (2,4)(3,5)]]
        """
        ans = []
        DS = self._gap_().DerivedSeries()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i], from_group = True))
        return ans
    
    def lower_central_series(self):
        """
        Return the derived series of this group as a list of
        permutation groups.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.lower_central_series()        # somewhat random output
            [Permutation Group with generators [(1,2,3)(4,5), (3,4)],
             Permutation Group with generators [(1,5)(3,4), (1,5)(2,4), (1,3,5)]]

        """
        ans = []
        DS = self._gap_().LowerCentralSeriesOfGroup()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i], from_group = True))
        return ans

    def upper_central_series(self):
        """
        Return the derived series of this group as a list of
        permutation groups.

        EXAMPLES:
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.upper_central_series()        # somewhat random output
            [Permutation Group with generators [()]]
        """
        ans = []
        DS = self._gap_().UpperCentralSeriesOfGroup()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i], from_group = True))
        return ans

def direct_product_permgroups(P):
    """
    Takes the direct product of the permutation groups listed in P.

    EXAMPLES:
        sage: G1 = AlternatingGroup([1,2,4,5])
        sage: G2 = AlternatingGroup([3,4,6,7])
        sage: D = direct_product_permgroups([G1,G2,G1])
        sage: D.order()
        1728
        sage: D = direct_product_permgroups([G1])
        sage: D==G1
        True
        sage: direct_product_permgroups([])
        Symmetric group of order 0! as a permutation group
    """
    from permgroup_named import SymmetricGroup
    n = len(P)
    if n == 0:
        return SymmetricGroup(1)
    if n == 1:
        return P[0]
    from sage.groups.perm_gps.permgroup_morphism import PermutationGroupMorphism_from_gap
    G = [H._gap_init_() for H in P]
    Glist = ""
    for H in G:
        Glist = Glist + H + ","
    cmd = "G:=DirectProduct([" + Glist[:-1] + "])"
    gap.eval(cmd)
    return PermutationGroup(gap.eval("G"), from_group = True)


class PermutationGroup_subgroup(PermutationGroup_generic):
    """
    Subgroup subclass of PermutationGroup_generic, so instance methods are
    inherited.

    EXAMPLES:
        sage: G = CyclicPermutationGroup(4)
        sage: gens = G.gens()
        sage: H = DihedralGroup(4)
        sage: PermutationGroup_subgroup(H,list(gens))
        Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]
        sage: K=PermutationGroup_subgroup(H,list(gens))
        sage: K.list()
        [(), (1,2,3,4), (1,3)(2,4), (1,4,3,2)]
        sage: K.ambient_group()
        Dihedral group of order 8 as a permutation group
        sage: K.gens()
        [(1,2,3,4)]
    """
    def __init__(self, ambient, gens, from_group = False, 
                 check=True):
        if not isinstance(ambient, PermutationGroup_generic):
            raise TypeError, "ambient (=%s) must be perm group."%ambient
        if not isinstance(gens, list):
            raise TypeError, "gens (=%s) must be a list"%gens
        if check:
            pass
            
        self.__ambient_group = ambient
        self.__gens = gens
        cmd = 'Group(%s)'%gens
        cmd = cmd.replace("'","")  # get rid of quotes
        self.__gap = cmd
   
        G = ambient
        if check:
            for i in range(len(gens)):
                x = gens[i]
                if not (G.has_element(x)):
                    raise TypeError, "each generator must be in the ambient group"
        self.__ambient_group = G
        
        PermutationGroup_generic.__init__(self, gens, from_group, check)

    def __cmp__(self, other):
        r"""
        Compare self and other.  If self and other are in a common ambient group,
        then self <= other precisely if self is contained in other. 
        
        EXAMPLES:
            sage: G = CyclicPermutationGroup(4)
	    sage: gens = G.gens()
	    sage: H = DihedralGroup(4)
 	    sage: PermutationGroup_subgroup(H,list(gens))
            Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]
	    sage: K=PermutationGroup_subgroup(H,list(gens))
            sage: G<K
            False
            sage: G>K
            False
        """
        if self is other:
            return 0
        if not isinstance(other, PermutationGroup_generic):
            return -1
        c = cmp(self.ambient_group(), other.ambient_group())
        if c: return c
        if self.is_subgroup(other):
            return -1
        else:
            return 1
            
    def _repr_(self):
        s = "Subgroup of %s generated by %s"%(self.ambient_group(), self.gens())
        return s

    def _latex_(self):
        r"""
        Return latex representation of this group.
        """
        return self._repr_()

        
    def ambient_group(self):
        """
        Return the ambient group related to self.
        """
        return self.__ambient_group

    def gens(self):
        """
        Return the generators for this subgroup.
        """
        return self.__gens
    
