def print_header():
  import sys
  print """/* Copyright (c) 2001 The Regents of the University of California through
   E.O. Lawrence Berkeley National Laboratory, subject to approval by the
   U.S. Department of Energy. See files COPYRIGHT.txt and
   cctbx/LICENSE.txt for further details.

   Revision history:
     2002 Apr: split into blocks (rwgk)
     2001 May 31: merged from CVS branch sgtbx_type (R.W. Grosse-Kunstleve)
     Apr 2001: SourceForge release (R.W. Grosse-Kunstleve)
               Based on C code contributed by Vincent Favre-Nicolin.

   *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************

   Generated by:
     %s
 */

#include <cctbx/eltbx/basic.h>
#include <cctbx/eltbx/henke.h>

namespace cctbx { namespace eltbx {
  namespace tables {
""" % (sys.argv[0],)

def print_ftp_info():
  print """/*
  Henke Tables

  The original data can be found at:
    ftp://grace.lbl.gov/pub/sf/

  From ftp://grace.lbl.gov/pub/sf/read.me:

                Low-Energy X-ray Interaction Coefficients:
                Photoabsorption, Scattering, and Reflection
                        E = 30-30,000 eV, Z = 1-92

                B. L. Henke, E. M. Gullikson, and J. C. Davis
                        Center for X-Ray Optics, 2-400
                        Lawrence Berkeley Laboratory
                        Berkeley, California 94720

  Reference: B. L. Henke, E. M. Gullikson, and J. C. Davis,
  Atomic Data and Nuclear Data Tables Vol. 54 No. 2 (July 1993).
 */
"""

def collect_tables(henke_tables_dir = "../reference/henke/tables"):
  import os, os.path, string
  nff_files = []
  for file in os.listdir(henke_tables_dir):
    fn = file.lower().capitalize()
    if (fn[-4:] == ".nff"): nff_files.append(file)
  tables = [0] * 120
  for file in nff_files:
    f = open(os.path.join(henke_tables_dir, file), "r")
    header = f.readline()
    table = f.readlines()
    f.close()
    Symbol = header[1:3].strip()
    Z = int(header[7:9])
    assert len(Symbol) > 0
    assert Symbol[0] in string.lowercase
    assert Symbol[-1] in string.lowercase
    assert Z > 0 and Z < len(tables)
    assert tables[Z] == 0
    Symbol = Symbol.capitalize()
    tables[Z] = (Symbol, table)
  Z = tables[1:].index(0) + 1
  rest = tables[Z:]
  assert rest == [0] * len(rest)
  tables = tables[:Z]
  return tables

def print_table_block(tables, Z_begin, Z_end, define_noval=0):
  # Visual C++ 7.0 compilation is very slow with define_noval=1
  if (define_noval): print "#define NOVAL Efpfdp_undefined"
  print "// BEGIN_COMPILED_IN_REFERENCE_DATA"
  for Z in xrange(Z_begin, Z_end):
    tab = tables[Z]
    print "eltbx::detail::Efpfdp Efpfdp_" + tab[0] \
      + "[] = { /* Z = " + str(Z) + " */"
    for line in tab[1]:
      flds = line.split()
      assert len(flds) == 3
      if (define_noval and flds[1] == "-9999.00"): flds[1] = "NOVAL"
      print "{%s, %s, %s}," % tuple(flds)
    print "{0, 0, 0}"
    print "};"
    print
  print "// END_COMPILED_IN_REFERENCE_DATA"
  if (define_noval): print "#undef NOVAL"
  print "}}} // namespace cctbx::eltbx::tables"

def print_henke_cpp(tables):
  for tab in tables[1:]:
    print "extern eltbx::detail::Efpfdp Efpfdp_" + tab[0] + "[];"
  print
  print "static const eltbx::detail::Label_Z_Efpfdp HenkeTables[] = {"
  i = 0
  for tab in tables[1:]:
    i += 1
    print "{\"" + tab[0] + "\", " + str(i) + ", Efpfdp_" + tab[0] + "},"
  print "{0, 0, 0}"
  print "};"
  print """
  } // namespace tables

  Henke::Henke(std::string const& Label, bool Exact)
  {
    std::string WorkLabel = StripLabel(Label, Exact);
    m_Label_Z_Efpfdp = detail::FindEntry(tables::HenkeTables, WorkLabel, Exact);
  }

  fpfdp Henke::operator()(double Energy)
  {
    fpfdp raw = detail::interpolate(m_Label_Z_Efpfdp, Energy);
    if (!raw.isValid_fp()) return raw;
    // subtract the number of electrons
    return fpfdp(raw.fp() - m_Label_Z_Efpfdp->Z, raw.fdp());
  }

}} // namespace cctbx::eltbx"""

def collect_points(lines):
  points = []
  for line in lines:
    points.append(line.split()[0])
  return points

def collect_tab_points(tables):
  tab_points = []
  for tab in tables[1:]:
    tab_points.append(collect_points(tab[1]))
  return tab_points

def compare_points(tables):
  tab_points = collect_tab_points(tables)
  for i in xrange(len(tab_points)-1):
    for j in xrange(i+1, len(tab_points)):
      if (tab_points[i] == tab_points[j]):
        print "points %d==%d" % (i+1,j+1)

def run():
  import sys
  tables = collect_tables()
  compare_points(tables) # establish that each list of data points is unique
  f = open("henke.cpp", "w")
  sys.stdout = f
  print_header()
  print_ftp_info()
  print_henke_cpp(tables)
  f.close()
  Z_block = 12
  for Z_begin in xrange(1, len(tables), Z_block):
    Z_end = min(len(tables), Z_begin + Z_block)
    f = open("henke_tables_%02d_%02d.cpp" % (Z_begin, Z_end-1), "w")
    sys.stdout = f
    print_header()
    print_table_block(tables, Z_begin, Z_end)
    f.close()
  sys.stdout = sys.__stdout__

if (__name__ == "__main__"):
  run()
