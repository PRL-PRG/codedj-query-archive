#!/usr/bin/env python
import re, os, os.path, sys

propbegindef=re.compile(r'\s*class\s+(?P<name>\w+)(\s*:\s*public\s+(?P<parent>\w+))?')
oranstuffdef=re.compile(r'\s*__REGISTER(?P<abstract>_ABSTRACT)?_CLASS')
propdef=re.compile(r'\s*(?P<ctype>\w+)\s+(?P<cname>\w+)\s*;\s*//P(?P<flags>\w+)?\s*(\((?P<pnameflag>[>+])(?P<pname>\w+)\s*\))?(?P<pdesc>[^\r\n]*)')
compdef=re.compile(r'\s*(?P<ctype>\w+)\s+(?P<cname>\w+)\s*;\s*//C')

propwarndef=re.compile(r'\\\\P')
compwarndef=re.compile(r'\s*__component')

tdidtdef = re.compile('\s*DEFINEDESCENDER\s*\(\s*(?P<name>\w*)')
callbackdef = re.compile('\s*((DEFINE_BUT_OPERATOR)|(DEFINE_CALLBACK))\s*\(\s*(?P<name>\w*)\s*,\s*(?P<parent>\w*)')

listdef = re.compile(r'\s*#define\s+(?P<name>\w+)\s+(?P<containertype>((_?TOrangeVector)|(TOrangeMap_K?V?))[<].+[>])')

notice = \
""" /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */

#include "../%s"
"""

listSet = \
"""
  cd = &%(containertype)s::st_classDescription;
  cd->name = "%(name)s";
  cd->type = &typeid(%(containertype)s>);
  cd->base = &TOrange::st_classDescription;
  cd->properties = TOrange_properties;
  cd->components = TOrange_components;
"""


def samefiles(n1, n2):
  f1, f2 = open(n1, "rt"), open(n2, "rt")
  same = (f1.readlines()==f2.readlines())
  f1.close()
  f2.close()
  return same

class ClassDefinition:
    def __init__(self, name, parent, abstract = 0):
        if name == "type":
          print 0
        self.name = name
        self.parent = parent
        self.abstract = abstract
        self.properties = []
        self.components = []
        self.confirmed = 0
        self.extended = 0

class ListDefinition:
    def __init__(self, name, elementtype):
        self.name = name
        self.elementtype = elementtype
        
def tf(x):
    return x and "true" or "false"


def storeClass(currentClass, hppfile):
  if currentClass:
    classes[currentClass.name] = currentClass
    if files.has_key(hppfile):
      files[hppfile].append(currentClass)
    else:
      files[hppfile] = [currentClass]

normalTypes = ["bool", "int", "float", "string", "TValue"]

noclasswarnings = []

def detectBuiltInProperties(hppfile):
    ff = open(hppfile, "rt")

    istdidt = hppfile=="tdidt.hpp"
    iscallback = hppfile=="callback.hpp"

    currentClass = None
    candidate = candidateBase = ""
    lcount = 0
    for line in ff:
      lcount += 1
      if istdidt:
          found = tdidtdef.match(line)
          if found:
                storeClass(currentClass, hppfile)
                currentClass = ClassDefinition("TTreeDescender_"+found.group("name"), "TTreeDescender")
                continue
      if iscallback:
          found = callbackdef.match(line)
          if found:
                storeClass(currentClass, hppfile)
                currentClass = apply(ClassDefinition, found.group("name", "parent"))
                continue

      found = propbegindef.match(line)
      if found:
        candidate, candidateBase = found.group("name", "parent")
        if candidateBase == "TOrangeVector":
          candidateBase = "TOrange"
        continue

      found = oranstuffdef.match(line)
      if found and candidate:
        storeClass(currentClass, hppfile)
        currentClass = ClassDefinition(candidate, candidateBase, found.group("abstract")!=None)
        continue

      found = propdef.match(line)
      if found:
        if not currentClass:
            print "%s(%i): Warning: property definition out of scope. Ignoring." % (hppfile, lcount)
        else:
            ctype, cname, flags, pnameflag, pname, pdesc = found.group("ctype", "cname", "flags", "pnameflag", "pname", "pdesc")
            normal = ctype in normalTypes
            if not normal and ctype[0]=="P":
              ctype = "T"+ctype[1:]
            if pname:
              if pnameflag=="+":
                pname = (cname, pname)
            else:
              pname = cname
            currentClass.properties.append((ctype, cname, pname, pdesc, flags and ("R" in flags) or 0, flags and ("O" in flags) or 0, normal))
        continue

      found = compdef.match(line)
      if found:
        if not currentClass:
            print "%s(%i): Warning: component definition out of scope. Ignoring." % (hppfile, lcount)
        else:
            ctype, cname = found.group("ctype", "cname")
            if ctype in normalTypes:
              print "%s(%i): Warning: component of non-wrapped type?! Ignoring." % (hppfile, lcount)
            currentClass.components.append(cname)

      found = listdef.search(line)
      if found:
        lists.append(found.group("name", "containertype")+(hppfile,))
        noclasswarnings.append(found.group("name"))
        continue
      
      found = propwarndef.match(line)
      if found:
        print "%s(%i): Warning: invalid property/component definition." % (hppfile, lcount)
        print "  " + line
        continue
        
    storeClass(currentClass, hppfile)
            

def renewFile(pppfile, newfile):
    oldexists = os.path.isfile(pppfile)
    if oldexists:
        if not samefiles(pppfile, newfile):
          os.remove(pppfile)
          os.rename(newfile, pppfile)
          print "Renewing " + pppfile
        else:
          os.remove(newfile)
#          print "Keeping " + pppfile
    else:
        os.rename(newfile, pppfile)
        print "Creating " + pppfile


def writeFile(hppfile):
    stem = hppfile[:-4]
    newfile = "ppp/%s.ppp.new" % stem
    pppfile = "ppp/%s.ppp" % stem
    
    off = open(newfile, "wt")
    off.write(notice % hppfile)

# - add parent fields
# - correct property types (P* -> T*)
    extern_classdefs = {}
    for classdef in files[hppfile]:
        tempcd = classes[classdef.parent]
        while tempcd:
            classdef.properties.extend(tempcd.properties)
            classdef.components.extend(tempcd.components)
            if tempcd.extended:
                break
            tempcd = classes[tempcd.parent]
        classdef.extended = 1

    for classdef in files[hppfile]:
        classname = classdef.name
        
        off.write("\n\n/****** %s *****/\n\n" % classname)
        
        off.write("TPropertyDescription %s_properties[] = {\n" % classname)
        for ctype, cname, pname, pdesc, ro, ob, builtin in classdef.properties:
            if builtin or (ctype=="TExample"):
                if type(pname)==tuple:
                  off.write('  {"%s", "%s", &typeid(%s), NULL, offsetof(%s, %s), %s, %s},\n' % (pname[0], pdesc, ctype, classname, cname, tf(ro), tf(ob)))
                  off.write('  {"%s", "%s", &typeid(%s), NULL, offsetof(%s, %s), %s, %s},\n' % (pname[1], pdesc, ctype, classname, cname, tf(ro), tf(ob)))
                else:
                  off.write('  {"%s", "%s", &typeid(%s), NULL, offsetof(%s, %s), %s, %s},\n' % (pname, pdesc, ctype, classname, cname, tf(ro), tf(ob)))
            else:
                if not classes.has_key(ctype) and not ctype in noclasswarnings:
                    print "Warning: type %s, required by %s.%s not registered" % (ctype, classname, pname)
                if type(pname)==tuple:
                  off.write('  {"%s", "%s", &typeid(POrange), &%s::st_classDescription, offsetof(%s, %s), %s, %s},\n' % (pname[0], pdesc, ctype, classname, cname, tf(ro), tf(ob)))
                  off.write('  {"%s", "%s", &typeid(POrange), &%s::st_classDescription, offsetof(%s, %s), %s, %s},\n' % (pname[1], pdesc, ctype, classname, cname, tf(ro), tf(ob)))
                else:
                  off.write('  {"%s", "%s", &typeid(POrange), &%s::st_classDescription, offsetof(%s, %s), %s, %s},\n' % (pname, pdesc, ctype, classname, cname, tf(ro), tf(ob)))
        off.write('  {NULL}\n};\n\n')

        off.write("size_t const %s_components[] = { " % classname)
        for ctype, cname, pname, pdesc, ro, ob, builtin in classdef.properties:
            if not builtin:
                off.write('offsetof(%s, %s), ' % (classname, cname))
        for component in classdef.components:
                off.write('offsetof(%s, %s), ' % (classname, component))
        off.write('0};\n')

        if classdef.parent:
            off.write(('TClassDescription %s::st_classDescription("%s", &typeid(%s), &%s::st_classDescription, %s_properties, %s_components);\n' +
                       'TClassDescription const *%s::classDescription() const { return &%s::st_classDescription; }\n'
                      ) % (tuple([classname]*3) + (classdef.parent, ) + tuple([classname]*4)))
        else:
            off.write(('TClassDescription %s::st_classDescription("%s", &typeid(%s), NULL, %s_properties, %s_components );\n' +
                       'TClassDescription const *%s::classDescription() const { return &%s::st_classDescription; }\n'
                      ) % tuple([classname]*7))
        if not classdef.abstract:
            off.write('TOrange *%s::clone() const { return mlnew %s(*this); }\n' % (classname, classname))

    off.close()

    renewFile(pppfile, newfile)


def writeLists():
    newfile = "ppp/orvector.ppp.new"
    pppfile = "ppp/orvector.ppp"
    
    off = open(newfile, "wt")

    off.write(notice % "orvector.hpp" + "\n\n")

    includefiles = dict([(n[2], 0) for n in lists])
    includefiles = includefiles.keys()
    includefiles.sort()
    for i in includefiles:
        off.write('#include "%s"\n' % i)
        
    off.write('\n#include "root.hpp"\n\n')

    containertypes = dict([(n[1], n[0]) for n in lists])
    containertypes = containertypes.items()
    containertypes.sort()

    for containertype, name in containertypes:
        off.write("TClassDescription %s::st_classDescription;\n" % containertype)
    off.write("\n")

    off.write("bool initializeVectorDescriptions()\n{\n  TClassDescription *cd;\n")

    for containertype, name in containertypes:
        off.write(listSet % {'containertype': containertype, 'name': name})

    off.write("  return false;\n}\n\nbool foo = initializeVectorDescriptions();")

    off.close()

    renewFile(pppfile, newfile)    


orig_dir = os.getcwd()

if len(sys.argv)<2:
    os.chdir("..")
else:
    os.chdir(sys.argv[1])

if not os.path.isdir("ppp"):
  os.mkdir("ppp")


files = {}
classes = { None: None}
lists = []
maps = []

for filename in filter(lambda x: x[-4:]==".hpp", os.listdir(".")):
    detectBuiltInProperties(filename)

for filename in files.keys():
    writeFile(filename)

writeLists()

f=open("ppp/stamp", "wt")
f.close()
    
os.chdir(orig_dir)
