import time, DbCore

FAILED = 0
SUCCESS = 1

_debug  = None
def timeStamp():
  stamp = time.strftime("%d-%m-%Y %H:%M.%S",time.localtime())
  return stamp

def fail(*parm):
  s = timeStamp()+' '
  for p in parm:
    s = s + str(p)
  return (FAILED,s)

tablePrefix   = 'ResMgr'
ResourceTable = tablePrefix+'Resources'
Connection    = None
DataSource    = "ResourceDatabase"

class ResourceException(Exception):
  def __init__(self, msg):
    Exception.__init__(self, msg)
  def __str__(self):
    return 'ResourceException: '+self.args[0]

class ResourceDatabase:
  """ ResourceDatabase class

      The resource database managers resources. Resources are singletons
      identified by name and can be booked by clients.
      
      The implementation is based on a database, which also ensures
      the uniqueness of resources.
      
      @author  M.Frank
      @version 1.0
  """
  Conn   = Connection
  Source = DataSource
  def __init__(self):
    if ( ResourceDatabase.Conn is None ):
      ResourceDatabase.Conn = DbCore.DbCore(ResourceDatabase.Source)
    self.core  = ResourceDatabase.Conn

  def db(self):
    return DbCore.DbCore(self.core)

  def _exec(self, stmt, OnErrorContinue, Print=0):
    """ Simple wrapper to execute a SQL database statement.
    """
    try:
      result = self.db().execute(stmt)
    except Exception, X:
      if ( not OnErrorContinue ):
        raise RunDatabaseException('Failed to execute statement '+stmt,'\n',X)
      if ( Print ):
        print fail('Failed to execute statement ',stmt,'\n',str(X))
      return fail(X)
    return (SUCCESS,result)

  def create(self, resnam, size, initial):
    """ Create a generic resource
      *
      * This routine will create an entry in the Resource
      * Manager Generic Resource Database (provided the resource
      * does not already exist) that defines a particular resource
      * as being either a limited or sequential resource.
      *
      * Calling syntax:
      * rm_create  resnam, size, initial
      *
      * @param  resnam   [IN]   Name of the resource.
      * @param  size     [IN]   The size of the limited generic resource or zero 
      *                         for sequential resources. This argument tells the 
      *                         RM how many copies it can generate of a particular 
      *                         resource.
      * @param  initial  [IN]   The starting value for the sequence generated by 
      *                         calling rm_book. For sequential resources, 
      *                         the numbers returned will be an integer sequence 
      *                         commencing at this value. For limited resources, 
      *                         this is the smallest copy number, the largest being
      *                         initial_value + size.
      *
      * @return Tuple with first entry being a Longword condition value. Bite 0 is set on SUCCESS
      *                    second entry contains either the error message or the result.
      """
    field = ''
    if ( size > 255 ):
      return fail(size,' exceeds the maximal number of copies for a resource.')
    if ( size > 0 ):
      field = field.ljust(size,'0')
      stmt = "INSERT INTO "+ResourceTable+" (Name, Size, Initial, Val, Field) \
              VALUES ('"+resnam+"',"+str(size)+","+str(initial)+","+str(initial)+",'"+field+"')"
      res = self._exec(stmt,1)
      if ( res[0] == SUCCESS ):
        return (SUCCESS,)
      return fail(res[1])
    stmt = "INSERT INTO "+ResourceTable+" (Name, Size, Initial, Val, Field) \
            VALUES ('"+resnam+"',"+str(size)+","+str(initial)+","+str(initial)+",'Sequential')"
    res = self._exec(stmt,1)
    if ( res[0] == SUCCESS ):
      return (SUCCESS,)
    return fail(res[1])
    
  def delete(self, resnam):
    """ Delete a generic resource
      * This routine removes the resource entry in the Resource Manager Generic 
      * Resource Database, provided the resource exists and is not occupied.    *
      *
      * Calling syntax:
      * rm_delete  resnam
      *
      * @param     resnam   [IN]   Name of the resource.
      *
      * @return Tuple with first entry being a Longword condition value. Bite 0 is set on SUCCESS
      *                    second entry contains either the error message or the result.
      """
    stmt = "DELETE FROM "+ResourceTable+" WHERE Name='"+resnam+"'"
    return self._exec(stmt,1)

  def get(self, resnam):
    stmt = "SELECT Name, Size, Initial, Val, Field FROM "+ResourceTable+" WHERE Name='"+resnam+"'"
    cur = DbCore.Cursor(self.db()).select(stmt)
    if ( cur.next().isSuccess() ):
      res = cur.result()
      if ( res is not None ):
        return (SUCCESS,res)
    return fail('Resource ',resnam,' does not exist')
    
  def exists(self, resnam):
    count = 0
    stmt = "SELECT COUNT(*) FROM "+ResourceTable+" WHERE Name='"+resnam+"'"
    cur = DbCore.Cursor(self.db()).select(stmt)
    if ( cur.next().isSuccess() ):
      count = self.db().executeQuery(stmt)[0]
    return (SUCCESS,count > 0)

  def last(self, resnam):
    """ Find the Last used Sequential Generic Resource
      *
      * This routine retrieves the number of the last used resource in the sequence 
      * for a Sequential resource, provided the resource has been created as a 
      * generic resource.
      *
      * @param  resnam   [IN]   Name of the resource.
      * @param  resnum   [OUT]  Number of generic resource that was last successfully booked.
      *
      * @return Tuple with first entry being a Longword condition value. Bite 0 is set on SUCCESS
      *                    second entry contains either the error message or the result.
    """
    res = self.get(resnam)
    if ( res[0] == SUCCESS ):
      return (SUCCESS,res[1][3])
    return fail(res[1])

  def book(self, resnam):
    """ Book a Generic Resource
      * This routine checks the compatibility of the booking
      * request with what is currently occupied, verifies that
      * the resource has been created as a generic resource,
      * and, if compatible, books the resource exclusively.
      *
      * Calling syntax:
      * rm_book  resnam, resnum
      *
      * @param   resnam   [IN]   Name of the resource.
      *
      * @return Tuple with first entry being a Longword condition value. Bite 0 is set on SUCCESS
      *                    second entry contains either the error message or the result.
    """
    stmt = "UPDATE "+ResourceTable+" SET Val=Val+1 "+\
           "WHERE Name='"+resnam+"' "+\
           "AND Field='Sequential'"
    res = self._exec(stmt, 1)
    if ( res[1] == 1 ):  # Yes, this was a sequential resource
      stmt = "SELECT Val FROM "+ResourceTable+" WHERE Name='"+resnam+"'"
      res = self.db().executeQuery(stmt)
      if ( len(res) > 0 ):
        return (SUCCESS,res[0][0])
      return fail('Internal Error. Cannot book the resource:',resnam)
    res = self.get(resnam)
    if ( res[0] == SUCCESS ):
      res = res[1]
      siz     = res[1]
      initial = res[2]
      value   = res[3]
      if   ( siz == value-initial  ):
        pass
      elif ( siz > value-initial ):
        field = res[4]
        idx = field.find('0')
        if ( idx >= 0 ):
          field = field.replace('0','1',1)
          stmt = "UPDATE "+ResourceTable+" "+\
                 "SET Field='"+field+"', Val="+str(idx+initial)+" "+\
                 "WHERE Name='"+resnam+"'"
          # print 'book', stmt
          res = self._exec(stmt, 1)
          if ( res[0] == SUCCESS ):
            if ( res[1] == 1 ):
              return (SUCCESS,idx+initial)
            return fail('Internal error. Several resources are matching ',resnam)
          return fail('Internal error. No resources is matching ',resnam)
      return fail('Cannot book the resource:',resnam,'. ',\
                  'The allowed number of sources:',res[1],' is exhausted.')
    return fail('Cannot book the resource:',resnam,'. The resource does not exist.')

  def release(self, resnam, copy):
    """ Release a Generic Resource
      *
      * This routine releases a Generic resource from the caller's use. It can 
      * only be used for LIMITED resources as Sequential resources can never be 
      * returned once booked (i.e. Run numbers cannot repeat).
      * 
      * Calling syntax:
      * rm_release  resnam, copy
      *
      * @param  resnam   [IN]   Name of the resource.
      * @param  copy    [OUT]   Copy number of the Limited generic resource that has been
      *                         successfully booked and should now be released.
      *
      * @return Tuple with first entry being a Longword condition value. Bite 0 is set on SUCCESS
      *                    second entry contains either the error message or the result.
    """
    if ( copy >= 0 ):
      resource = self.get(resnam)
      if ( resource[0] == SUCCESS ):
        res = resource[1]
        if (res[1] > 0):
          initial = res[2]
          field = res[4]
          idx = copy-initial
          if ( idx >= 0 and idx < len(field) ):
            item = field[idx:idx+1]
            # print 'release:', idx, ' copy=', copy, initial, res[1], ' item = ',item
            if ( item == '1' ):
              f = field[:idx]+'0'+field[idx+1:]
              stmt = "UPDATE "+ResourceTable+" SET Field='"+f+"' WHERE Name='"+resnam+"'"
              res = self._exec(stmt, 1)
              if ( res[0] == SUCCESS ):
                return (SUCCESS,)
              return fail('Internal error. The resource '+resnam+' cannot be released.')
            return fail('Invalid resource copy:',copy,'. The resource '+resnam+' was not allocated.')
          return fail('Resource copy:',copy,' out of range. The resource '+resnam+' cannot be released.')
        return fail('The sequential resource '+resnam+' cannot be released.')
      return fail('Cannot book the resource:',resnam,'. The resource does not exist.')
    return fail('Negative resource copy values are invalid')

  #============================================================================
  def uninstall(self, OnErrorContinue=1):
    """ Uninstall the Resource database. All basic tables and indices are dropped.

        @author M.Frank
    """
    self._exec('DROP TABLE ' + ResourceTable, OnErrorContinue)
    if ( not OnErrorContinue ):
      return (SUCCESS,'Deinstallation succeeded.' )
    return (SUCCESS,'Deinstallation finished (need to check printout)')

  def _make(self, stmt,OnErrorContinue):
    self._exec(stmt,1,1)

  #============================================================================
  def install(self, OnErrorContinue=1):
    """ Install Resource database from scratch. Only the basic tables and keys are defined.
        No attempt here is taken to optimize the data access in any way.

        @author M.Frank
    """
    make = self._make
    # Create Runs table
    make('CREATE TABLE '+ResourceTable+'(Name VARCHAR(32), Size INTEGER, Initial INTEGER, Val INTEGER, Field VARCHAR(255))',OnErrorContinue)
    make('ALTER TABLE  '+ResourceTable+' ADD PRIMARY KEY (Name)',OnErrorContinue)    
    if ( not OnErrorContinue ):
      return (SUCCESS,'Installation succeeded.')
    return (SUCCESS,'Installation finished (need to check printout)')

  #============================================================================
  def dump(self,**options):
    """ Dump database content.

        @author M.Frank
    """    
    try:
      result = ''
      opt = getSQL(**options)
      print result
      return (SUCCESS,result)
    except Exception, X:
      result = result + 'Exception:\n'%str(X)
      return (FAILED,str(X))
    return (FAILED,'')

def rm_install():
  res = ResourceDatabase().install(1)
  print 'ResourceDatabase.install() returned:', str(res)
  return res
  
def rm_uninstall():
  res = ResourceDatabase().uninstall(1)
  print 'ResourceDatabase.uninstall() returned:', str(res)
  return res

def rm_create(resnam, size, initial):
  return ResourceDatabase().create(resnam, size, initial)
  
def rm_delete(resnam):
  return ResourceDatabase().delete(resnam)

def rm_last(resnam):
  return ResourceDatabase().last(resnam)

def rm_release(resnam, copy):
  return ResourceDatabase().release(resnam, copy)

def rm_book(resnam):
  return ResourceDatabase().book(resnam)

def rm_get(resnam):
  return ResourceDatabase().get(resnam)

def rm_exists(resnam):
  return ResourceDatabase().exists(resnam)
