import zope.interface
import zope.interface.common.mapping
import zope.interface.common.sequence
import zope.component.interfaces
import zc.queue.interfaces
from zc.async.i18n import _

PENDING = _('pending-state', 'Pending')
ACTIVE = _('active-state', 'Active')
CALLBACKS = _('callback-state', 'Performing Callbacks')
COMPLETED = _('completed-state', 'Completed')

class AbortedError(Exception):
    """An explicit abort, as generated by the default behavior of
    IPartial.fail"""

class BadStateError(Exception):
    """The partial is not in the state it should be for the call being made.
    This is almost certainly a programmer error."""

class IPartialFactory(zope.interface.Interface):

    def __call__(self, call, *args, **kwargs):
        """return an IPartial with the given call, args, and kwargs"""

    def bind(self, call, *args, **kwargs):
        """returns IPartial with the IPartial inserted as first value in args.
        """

class IPartial(zope.interface.Interface):

    __parent__ = zope.interface.Attribute(
        """The current canonical location of the partial""")

    callable = zope.interface.Attribute(
        """The callable object that should be called with *IPartial.args and
        **IPartial.kwargs when the IPartial is called.  Mutable.""")

    args = zope.interface.Attribute(
        """a peristent list of the args that should be applied to self.call.
        May include persistent objects (though note that, if passing a method
        is desired, it will typicall need to be wrapped in an IPartial).""")

    kwargs = zope.interface.Attribute(
        """a persistent mapping of the kwargs that should be applied to
        self.call.  May include persistent objects (though note that, if
        passing a method is desired, it will typicall need to be wrapped
        in an IPartial).""")

    state = zope.interface.Attribute(
        """One of constants defined in zc.async.interfaces: PENDING,
        ACTIVE, CALLBACKS, COMPLETED.  PENDING means not yet called. 
        ACTIVE means in the process of being called.  CALLBACKS means in
        the process of calling callbacks.  COMPLETED means called.""")

    result = zope.interface.Attribute(
        """The result of the call.  When state equals PENDING or ACTIVE, will
        be None.  When COMPLETED, will be a twisted.python.failure.Failure
        describing the call failure or the successful result.""")

    callbacks = zope.interface.Attribute(
        """A mutable persistent list of the callback partials added by
        addCallbacks.""")

    unhandled_error = zope.interface.Attribute(
        """A boolean: whether this partial has an unhandled error.
        An unhandled error is defined as a Failure result on any callback
        leaf node, or a Failure on this partial if this has no callbacks
        or if it has one or more incomplete callback.""")

    annotations = zope.interface.Attribute(
        """An OOBTree that is available for metadata use.""")

    def addCallbacks(success=None, failure=None):
        """if success or failure is not None, adds a callback partial to
        self.callbacks and returns the partial.  Otherwise returns self.
        success and failure must be None or adaptable to IPartial.
        addCallbacks may be called multiple times.  Each will be called
        with the result of this partial.  If callback is already in COMPLETED
        state then the callback will be performed immediately."""

    def addCallback(callback):
        """callback will receive result (independent of whether it is a
        success or a failure).  callback must be adaptable to IPartial.
        addCallback may be called multiple times.  Each will be called
        with the result of this partial.  If callback is already in
        COMPLETED state then the callback will be performed immediately."""

    def __call__(*args, **kwargs):
        """call the callable.  Any given args are effectively appended to
        self.args for the call, and any kwargs effectively update self.kwargs
        for the call."""

    def fail(e=AbortedError):
        """Fail this partial, with option error e.  May only be called when
        partial is in PENDING or ACTIVE states, or else raises BadStateError.
        If e is not provided,"""

    def resumeCallbacks():
        """Make all callbacks remaining for this partial.  Any callbacks
        that are in PENDING state should be called normally; any callbacks
        in ACTIVE state should be `fail`ed; any callbacks in CALLBACKS state
        should `resumeCallback`; and any callbacks in COMPLETED state should
        be untouched.  May only be called when partial is in CALLBACKS state.
        State will be COMPLETED after this call."""

class IDataManagerPartial(IPartial):
    """An async partial with all the necessary knobs to by put in a
    datamanager."""

    workerUUID = zope.interface.Attribute(
        """The UUID of the IWorker who is, or was, responsible for this
        partial.  None initially.  Should be assigned by
        IWorker.[reactor|thread].put.""")

    assignerUUID = zope.interface.Attribute(
        """The UUID of the software instance that was in charge when the
        IPartial was put in an IPartialQueue.  Should be assigned by
        IPartialQueue.put.""")

    selectedUUIDs = zope.interface.Attribute(
        """a set of selected worker UUIDs.  If it is empty, it is
        interpreted as the set of all available workerUUIDs.  Only
        workers with UUIDs in the set may perform it.

        If a worker would have selected this partial for a run, but the
        difference of selected_workerUUIDs and excluded_workerUUIDs
        stopped it, it is responsible for verifying that the effective
        set of workerUUIDs intersects with the available workers; if the
        intersection contains no possible workers, the worker should
        call partial.fail().""")

    excludedUUIDs = zope.interface.Attribute(
        """a set of excluded worker UUIDs.  Workers with UUIDs in this
        set may not perform the partial.

        If a worker would have selected this partial for a run, but the
        difference of selected_workerUUIDs and excluded_workerUUIDs
        stopped it, it is responsible for verifying that the effective
        set of workerUUIDs intersects with the available workers; if the
        intersection contains no possible workers, the worker should
        call partial.fail().""")

    begin_after = zope.interface.Attribute(
        """A datetime.datetime in UTC of the first time when the
        partial may run.  Cannot be set after partial gets a data_manager.
        """)

    begin_by = zope.interface.Attribute(
        """A datetime.timedelta of the duration after the begin_after
        value after which the partial will fail, if it has not already
        begun.  Cannot be set after partial has begun.""")

    thread = zope.interface.Attribute(
        """None or thread.get_ident() of the worker who performs it.  If a
        reactor partial, must be None.""")

class IPartialQueue(zc.queue.interfaces.IQueue):

    __parent__ = zope.interface.Attribute(
        """the IDataManager of which this is a part.""")

    thread = zope.interface.Attribute(
        """boolean of whether this is a thread or reactor queue""")

    def put(item, begin_after=None, begin_by=None):
        """Put an IPartial adapted from item into the queue.  Returns IPartial.

        Rememeber that IPartials are not guaranteed to be run in order
        added to a queue.  If you need sequencing, use
        IPartial.addCallbacks.
        
        item must be an IPartial, or be adaptable to that interface.
        begin_after must be None (to leave the partial's current value) or a 
        datetime.datetime.  begin_by must be None (to leave it alone) or a
        datetime.timedelta of the duration after the begin_after.

        If item.begin_after is None and begin_after is None, begin_after will
        effectively be now.  If item.begin_by is None and begin_by is None,
        begin_by will effectively be datetime.timedelta(hours=1).

        datetime.datetimes are suggested to be in UTC.  Timezone-naive
        datetimes will be interpreted as in UTC.  Timezone-aware datetimes
        will be converted to UTC, and errors because of this (such as
        pytz ambiguity errors) will be raised.

        When an IPartial is put in the queue, the queue puts the
        begin_after time and begin_by duration on the partial,
        and the UUID of the Zope instance that put the partial in the
        queue on the `assignerUUID`.
        """

    def iterDue():
        """return an iterable of all partials whose begin_after value is
        less than or equal to now.  Any expired partials (begin_after +
        begin_by > datetime.datetime.now(pytz.UTC)) are also included.
        """

    def pullNext(UUID):
        """returns first due job that is available for the given UUID,
        removing it from the queue as appropriate; or None, if none are
        available. Responsible for including jobs to fail expired
        partials, and jobs to decomission dead workers for the next
        highest worker (sorted by UUID) if its (last_ping +
        ping_interval + ping_death_interval) < now.  If this is the
        highest worker UUID, cycles around to lowest."""

class IWorkers(zope.interface.common.mapping.IEnumerableMapping):

    __parent__ = zope.interface.Attribute(
        """the IDataManager of which this is a part.""")

    def add(value):
        """add an IWorker with key of value.UUID.  If value.UUID is None,
        raise ValueError.  Set value.__parent__ to the IWorkers."""

    def remove(UUID):
        """remove the registered IWorker with the give UUID.  Raise KeyError
        if such does not exist."""

class IDataManager(zope.interface.Interface):
    """Note that partials added to queues are not guaranteed to run in
    the order added.  For sequencing, use IPartial.addCallbacks."""

    thread = zope.interface.Attribute(
        """An IPartialQueue of IPartials that should be run in a thread.""")

    reactor = zope.interface.Attribute(
        """An IPartialQueue of IPartials that should be run in the main
        loop (e.g., Twisted's main reactor loop).""")

    workers = zope.interface.Attribute(
        """An IWorkers of registered IWorker objects for this data manager;
        these objects represent processes that are responsible for claiming
        and performing the IPartials in the data manager.""")

    def checkSibling(uuid):
        """check the next sibling of uuid to see if it is dead, according
        to its last_poll, and remove the engineUUID and schedule removal of its
        partials if it is dead."""

class IDataManagerAvailableEvent(zope.component.interfaces.IObjectEvent):
    """object is data manager"""

class DataManagerAvailable(zope.component.interfaces.ObjectEvent):
    zope.interface.implements(IDataManagerAvailableEvent)

class FullError(Exception):
    """Container is full.
    """

class ISizedSequence(zope.interface.common.sequence.IFiniteSequence):
    size = zope.interface.Attribute(
        """an integer.  If the queue's len >= size, put will raise
        FullError""")

    def add(item):
        """same contract as IQueue.put, except if queue's len >= size, put will
        raise FullError, and all objects get __parent__ set to the queue;
        and it will only store partials."""

    __parent__ = zope.interface.Attribute(
        """a link to parent: an IWorker""")

    def remove(item):
        """remove item, or raise ValueError if item is not in queue"""

    def __delitem__(index):
        """delete item at index"""

    def index(item):
        """return index, or raise ValueError if item is not in queue"""

class ICompletedCollection(zope.interface.Interface):
    def __iter__():
        """Iterate over partials in collection, from most recent `begin_after`
        to oldest"""

    def iter(start=None, stop=None):
        """Iterate over partials in collection, starting and stopping with
        given timezone-aware datetime values reasonably efficiently."""

    def __len__():
        """Return number of partials in collection"""

    def add(partial):
        """Add partial to collection and set __parent__ to the collection."""

    __parent__ = zope.interface.Attribute(
        """an IWorker""")

    rotation_interval = zope.interface.Attribute(
        """A datetime.timedelta of how often the buckets in the collection
        should be rotated, to clean them out.""")

    last_rotation = zope.interface.Attribute(
        """A datetime.datetime in pytz.UTC of the last time a rotation was
        performed (should initialize to the creation time).""")

    def first(start=None):
        """Return the first (most recent) partial in the collection, starting
        with optional timezone-aware datetime."""

    def last(stop=None):
        """Return the last (oldest) partial in the collection, stopping
        with optional timezone-aware datetime."""

    def __nonzero__():
        "whether collection contains any partials"

    def rotate():
        """rotate buckets, eliminating the ones added longest ago.  Note that
        this may be different than the ordering by begin_after."""

class IWorker(zope.interface.Interface):

    reactor = zope.interface.Attribute(
        """An ISizedQueue of reactor partials currently being worked on by this
        worker.""")

    thread = zope.interface.Attribute(
        """An ISizedQueue of thread partials currently being worked on by this
        worker.""")

    UUID = zope.interface.Attribute(
        """The uuid.UUID that identifies this worker (where one instance ==
        one process == one worker == one UUID).""")

    engineUUID = zope.interface.Attribute(
        """The uuid.UUID of the engine that is running this worker, or None.""")

    last_ping = zope.interface.Attribute(
        """the datetime.datetime in the pytz.UTC timezone of the last ping.
        This date should be updated anytime a worker accepts a job in a
        reactor or thread queue; and whenever, during a poll,
        (last_ping + ping_interval) <= now.""")

    poll_seconds = zope.interface.Attribute(
        """The number of seconds between the end of one worker poll and the
        start of the next.""")

    ping_interval = zope.interface.Attribute(
        """The approximate maximum datetime.timedelta between pings before
        a new last_ping should be recorded.""")

    ping_death_interval = zope.interface.Attribute(
        """the datetime.timedelta after the last_ping + ping_interval that
        signifies the workers death.  That is, if (last_ping + ping_interval +
        ping_death_interval) < now, the worker should be regarded as dead.
        """)

    completed = zope.interface.Attribute(
        """The most recent partials completed by this worker, in the order
        from most recent `begin_after` to oldest.  ICompletedCollection.""")

class IUUID(zope.interface.Interface):
    """A marker interface for the API of Ka-Ping Yee's uuid.UUID class.
    See http://zesty.ca/python/uuid.html """
