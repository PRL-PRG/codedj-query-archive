#!/usr/bin/env python

"""
Identify full taxonomic standing for sequences identified by gi number

usage: tax.py gi_list_file out_file columnNumber

    gi_list_file     - input file containing GI identifiers
    out_file         - output file
    idColumnNumber   - integer corresponding to column containing identifier that will be included into output
    giColumnNumber   - integer corresponding to column in gi_list_file containing GIs (column numbers start with 1)
    
"""

import pkg_resources
pkg_resources.require( 'bx-python' )
pkg_resources.require( 'pysqlite' )
import traceback
import fileinput
from pysqlite2 import dbapi2 as sqlite
from warnings import warn
import string, sys



TAXONOMY = '/Users/anton/galaxy/static/taxonomy/taxonomy.db'

#    database containing collapsed NCBI taxonomy generated by prepareTaxonomy.sh script 
#    distributed with Galaxy. See prepareTaxonomy.readme (in scripts/taxonomy ditrectory) for information on how to generate
#    necessary files

def main():
    
    try:
        gi_fname  = sys.argv[1]
        out_fname = sys.argv[2]
        idCol     = int( sys.argv[3] ) - 1
        giCol     = int( sys.argv[4] ) - 1
    except:
        sys.stderr.write('Not enough arguments\n')
        sys.exit(0)  
        
    try:
        con = sqlite.connect(TAXONOMY)
    except:
        sys.stderr.write('Cannot connect to database\n')
        sys.exit(0)  

    cur = con.cursor() 
    fg = open(gi_fname, 'r')
    of = open( out_fname, "w" )
    
    try:
        for line in fg:
                try:
                    field = string.split(line.rstrip(), '\t')
                    sqlTemplate = string.Template('select gi2tax.gi, tax.* from gi2tax left join tax on gi2tax.taxId = tax.taxId where gi2tax.gi = $gi') 
                    sql = sqlTemplate.substitute(gi = int(field[giCol]))
                    cur.execute(sql)

                    for item in cur.fetchall():
                        ranks = string.split(item[2], ",")
                        print >> of, field[idCol] + "\t" + str(item[0]) + "\t" + "\t".join(ranks) 
               
                except:
                    pass

    finally:
        fg.close()
        of.close()
        
if __name__ == "__main__":
    main()
