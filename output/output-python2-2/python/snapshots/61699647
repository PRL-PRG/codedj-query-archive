"""
Orders in number fields.

AUTHORS:
    -- William Stein and Robert Bradshaw (2007-09): initial version
"""

from sage.rings.ring import DedekindDomain
from number_field_element import OrderElement_absolute, OrderElement_relative
from sage.structure.sequence import Sequence
from sage.rings.integer_ring import ZZ

class Order(DedekindDomain):
    r"""
    An order in a number field.

    An order is a subring of the number field that has $\ZZ$-rank equal
    to the degree of the number field over $\QQ$.

    EXAMPLES:
        sage: K.<theta> = NumberField(x^4 + x + 17)
        sage: K.maximal_order()
        Order with module basis 1, theta, theta^2, theta^3 in Number Field in theta with defining polynomial x^4 + x + 17
        sage: K.order(17*theta)
        Order with module basis 1, 17*theta, 289*theta^2, 4913*theta^3 in Number Field in theta with defining polynomial x^4 + x + 17
        sage: K.order(17*theta, 13*theta)
        Order with module basis 1, theta, theta^2, theta^3 in Number Field in theta with defining polynomial x^4 + x + 17
        sage: K.order([34*theta, 17*theta + 17])
        Order with module basis 1, 17*theta, 289*theta^2, 4913*theta^3 in Number Field in theta with defining polynomial x^4 + x + 17
        sage: K.<b> = NumberField(x^4 + x^2 + 2)
        sage: (b^2).charpoly().factor()
        (x^2 + x + 2)^2
        sage: K.order(b^2)
        Traceback (most recent call last):
        ...
        ValueError: the rank of the span of gens is wrong
    """
    def __init__(self, K):
        self._K = K

    def gen(self, i):
        return self.basis()[i]

    def gens(self):
        return self.basis()

    def ngens(self):
        return len(self.basis())

    def basis(self):  # this must be defined in derived class
        raise NotImplementedError
        
    def number_field(self):
        """
        Return the number field of this order, which is the ambient
        number field that this order is embedded in.

        EXAMPLES:
            sage: K.<b> = NumberField(x^4 + x^2 + 2)
            sage: O = K.order(2*b); O
            Order with module basis 1, 2*b, 4*b^2, 8*b^3 in Number Field in b with defining polynomial x^4 + x^2 + 2
            sage: O.number_field()
            Number Field in b with defining polynomial x^4 + x^2 + 2
            sage: O.number_field() is K
            True
        """
        return self._K

    def ambient(self):
        r"""
        Return the ambient number field that contains self.

        This is the same as \code{self.number_field()} and
        \code{self.fraction_field()}

        EXAMPLES:
            sage: k.<z> = NumberField(x^2 - 389)
            sage: o = k.order(389*z + 1)
            sage: o
            Order with module basis 1, 389*z in Number Field in z with defining polynomial x^2 - 389
            sage: o.ambient()
            Number Field in z with defining polynomial x^2 - 389
        """
        return self._K

    
    def fraction_field(self):
        """
        Return the fraction field of this order, which is the
        ambient number field.

        EXAMPLES:
            sage: K.<b> = NumberField(x^4 + 17*x^2 + 17)
            sage: O = K.order(17*b); O
            Order with module basis 1, 17*b, 289*b^2, 4913*b^3 in Number Field in b with defining polynomial x^4 + 17*x^2 + 17
            sage: O.fraction_field()
            Number Field in b with defining polynomial x^4 + 17*x^2 + 17
        """
        return self._K
        
    def degree(self):
        r"""
        Return the degree of this order, which is the rank
        of this order as a $\ZZ$-module.

        EXAMPLES:
            sage: k.<c> = NumberField(x^3 + x^2 - 2*x+8)
            sage: o = k.maximal_order()
            sage: o.degree()
            3
            sage: o.rank()
            3
        """
        return self._K.degree()

    def rank(self):
        r"""
        Return the rank of this order, which is the rank of
        the underlying $\ZZ$-module, or the degree of the ambient
        number field that contains this order.

        This is a synonym for \code{self.degree()}.

        EXAMPLES:
            sage: k.<c> = NumberField(x^5 + x^2 + 1)
            sage: o = k.maximal_order(); o
            Order with module basis 1, c, c^2, c^3, c^4 in Number Field in c with defining polynomial x^5 + x^2 + 1
            sage: o.rank()
            5
        """
        return self.degree()
        
    def __eq__(left, right):
        """
        Returns whether or not these two orders are the same. 
        
        EXAMPLES: 
            sage: from sage.rings.number_field.order import *
            sage: x = polygen(QQ)
            sage: K.<a> = NumberField(x^3+2)
            sage: V, from_v, to_v = K.vector_space()
            sage: M = span(ZZ, [to_v(a), to_v(1)])
            sage: O = AbsoluteOrder(K, M); O
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a
            sage: M = span(ZZ, [to_v(a^2), to_v(1)])
            sage: O2 = AbsoluteOrder(K, M); O2
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a^2
            sage: O & O2
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1
            sage: O == O2
            False
            sage: O & O2 == ZZ
            True
        """
        if not isinstance(left, Order) or not isinstance(right, Order):
            if left is ZZ:
                return right.absolute_order()._module_rep.dimension() == 1
            elif right is ZZ:
                return left.absolute_order()._module_rep.dimension() == 1
            return False
        left = left.absolute_order()
        right = right.absolute_order()
        return left._K == right._K and left._module_rep == right._module_rep

class AbsoluteOrder(Order):

    def __init__(self, K, module_rep, check=True):
        """
        EXAMPLES: 
            sage: from sage.rings.number_field.order import *
            sage: x = polygen(QQ)
            sage: K.<a> = NumberField(x^3+2)
            sage: V, from_v, to_v = K.vector_space()
            sage: M = span(ZZ, [to_v(a), to_v(1)])
            sage: O = AbsoluteOrder(K, M); O
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a
            
            sage: M = span(ZZ, [to_v(a), to_v(2)])
            sage: O = AbsoluteOrder(K, M); O
            Traceback (most recent call last):
            ...
            ValueError: 1 is not in the span of the module, hence not an order.
            
            sage: loads(dumps(O)) == O
            True
        """
        Order.__init__(self, K)
        self._module_rep = module_rep
        V, from_v, to_v = self._K.vector_space()
        if check:
            if not K.is_absolute():
                raise ValueError, "AbsoluteOrder must be called with an absolute number field."
            if to_v(1) not in module_rep:
                raise ValueError, "1 is not in the span of the module, hence not an order."
            if module_rep.rank() != self._K.degree():
                raise ValueError, "the module must have full rank."
        
    def __call__(self, x):
        """
        Coerce x into this order.

        EXAMPLES:
            sage: k.<z> = NumberField(x^2 - 389)
            sage: m = k.order(3*z); m
            Order with module basis 1, 3*z in Number Field in z with defining polynomial x^2 - 389
            sage: m(6*z)
            6*z
        """
        if x.parent() is not self._K:
            x = self._K(x)
        V, _, embedding = self._K.vector_space()
        if not embedding(x) in self._module_rep:
            raise TypeError, "Not an element of the order."
        return OrderElement_absolute(self, x)
        
    def __add__(left, right):
        """
        Add two orders. 
        
        EXAMPLES: 
            sage: from sage.rings.number_field.order import *
            sage: K.<a> = NumberField(x^3+2)
            sage: V, from_v, to_v = K.vector_space()
            sage: M = span(ZZ, [to_v(a), to_v(1)])
            sage: O = AbsoluteOrder(K, M); O
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a
            sage: M = span(ZZ, [to_v(a^2), to_v(1)])
            sage: O2 = AbsoluteOrder(K, M); O2
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a^2
            sage: O+O2
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a, a^2
        """
        if not isinstance(left, AbsoluteOrder) or not isinstance(right, AbsoluteOrder):
            raise NotImplementedError
        if left.number_field() != right.number_field():
            raise TypeError, "Number fields don't match."
        return AbsoluteOrder(left._K, left._module_rep + right._module_rep, False)
        
    def __and__(left, right):
        """
        Intersect orders. 
        
        EXAMPLES: 
            sage: from sage.rings.number_field.order import *
            sage: K.<a> = NumberField(x^3+2)
            sage: V, from_v, to_v = K.vector_space()
            sage: M = span(ZZ, [to_v(a), to_v(1)])
            sage: O = AbsoluteOrder(K, M); O
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a
            sage: M = span(ZZ, [to_v(a^2), to_v(1)])
            sage: O2 = AbsoluteOrder(K, M); O2
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1, a^2
            sage: O & O2
            Order in Number Field in a with defining polynomial x^3 + 2 generated by 1
            sage: O & O2 == ZZ
            True
        """
        if not isinstance(left, AbsoluteOrder) or not isinstance(right, AbsoluteOrder):
            raise NotImplementedError
        if left.number_field() != right.number_field():
            raise TypeError, "Number fields don't match."
        return AbsoluteOrder(left._K, left._module_rep.intersection(right._module_rep), False)
        
    def index_in(self, other):
        """
        Return the index of self in other.  This is a lattice index,
        so it is a rational number if self isn't contained in other.

        INPUT:
            other -- another absolute order with the same ambient
            number field.

        OUTPUT:
            a rational number
        
        EXAMPLES:
            sage: k.<i> = NumberField(x^2 + 1)
            sage: O1 = k.order(i)
            sage: O5 = k.order(5*i)
            sage: O5.index_in(O1)
            5

            sage: k.<a> = NumberField(x^3 + x^2 - 2*x+8)
            sage: o = k.maximal_order()
            sage: o
            Order with module basis 1, 1/2*a^2 + 1/2*a, a^2 in Number Field in a with defining polynomial x^3 + x^2 - 2*x + 8
            sage: O1 = k.order(a); O1
            Order with module basis 1, a, a^2 in Number Field in a with defining polynomial x^3 + x^2 - 2*x + 8
            sage: O1.index_in(o)
            2
            sage: O2 = k.order(1+2*a); O2
            Order with module basis 1, 2*a, 4*a^2 in Number Field in a with defining polynomial x^3 + x^2 - 2*x + 8
            sage: o.index_in(O2)
            1/16
        """
        if not isinstance(other, AbsoluteOrder):
            raise TypeError, "other must be an absolute order."
        if other.ambient() != self.ambient():
            raise ValueError, "other must have the same ambient number field as self."
        return self._module_rep.index_in(other._module_rep)

    def free_module(self):
        """
        Returns the underlying free module corresponding to this
        order, embedded in the vector space corresponding to the
        ambient number field.

        EXAMPLES:
            sage: k.<a> = NumberField(x^3 + x + 3)
            sage: m = k.order(3*a); m
            Order with module basis 1, 3*a, 9*a^2 in Number Field in a with defining polynomial x^3 + x + 3
            sage: m.free_module()
            Free module of degree 3 and rank 3 over Integer Ring
            Echelon basis matrix:
            [1 0 0]
            [0 3 0]
            [0 0 9]
        """
        return self._module_rep
        
    def intersection(self, other):
        """
        Return the intersection of this order with another order.

        EXAMPLES:
            sage: k.<i> = NumberField(x^2 + 1)
            sage: O6 = k.order(6*i)
            sage: O9 = k.order(9*i)
            sage: O6.intersection(O9)
            Order with module basis 1, 18*i in Number Field in i with defining polynomial x^2 + 1
            sage: O6 & O9
            Order with module basis 1, 18*i in Number Field in i with defining polynomial x^2 + 1
            sage: O6 + O9
            Order with module basis 1, 3*i in Number Field in i with defining polynomial x^2 + 1
        """
        return self & other

    def _repr_(self):
        """
        Return print representation of this absolute order.

        EXAMPLES:
        """
        return "Order with module basis %s in %r" % (", ".join([str(b) for b in self.basis()]), self._K)
        
    def basis(self):
        """
        Return the basis over ZZ for this order.

        EXAMPLES:
            sage: k.<c> = NumberField(x^3 + x^2 + 1)
            sage: O = k.maximal_order(); O          1)
            Order with module basis 1, c, c^2 in Number Field in c with defining polynomial x^3 + x^2 + 1
            sage: O.basis()
            [1, c, c^2]

        The basis is an immutable sequence:
            sage: type(O.basis())
            <class 'sage.structure.sequence.Sequence'>

        The generator functionality uses the basis method:
            sage: O.0
            1
            sage: O.1
            c
            sage: O.gens()
            [1, c, c^2]
            sage: O.ngens()
            3
        """
        try:
            return self.__basis
        except AttributeError:
            V, from_V, to_V = self._K.vector_space()
            B = Sequence([from_V(b) for b in self._module_rep.basis()], immutable=True)
            self.__basis = B
        return B
        
    def absolute_order(self):
        """
        Return the absolute order associated to this order, which is
        just this order again since this is an absolute order.
        """
        return self
        

class RelativeOrder(Order):

    def __init__(self, K, absolute_order, base, embedding, check=True):
        Order.__init__(self, K)
        self._absolute_order = absolute_order
        self._base = base
        self._embedding = embedding
    
    def __call__(self, x):
        if x.parent() is not self._K:
            x = self._K(x)
        x = self._absolute_order(x) # will test membership
        return OrderElement_relative(self, x)

    def _repr_(self, x):
        """
        Return print representation of this relative order.
        """
        V, to_V, from_V = self._K.vector_space()
        basis = self._module_rep.basis()
        return "Order over %r spanned by %r" % (self._base, ",".join([from_V(b) for b in self._absolute_order.basis()]))
        
    def absolute_order(self):
        return self._absolute_order

    def __add__(left, right):
        """
        Add two orders. 
        """
        if isinstance(left, AbsoluteOrder):
            return left + right._absolute_order
        elif isinstance(right, AbsoluteOrder):
            return left._absolute_order + right
        elif isinstance(left, RelativeOrder) and isinstance(right, RelativeOrder):
            if left._K != right._K:
                raise TypeError, "Number fields don't match."
            if left._base != right._base:
                raise TypeError, "Bases don't match."
            if left._embedding != right._embedding:
                raise TypeError, "Embeddings don't match."
            return RelativeOrder(left._absolute_order + right._absolute_order, left._base, left._embedding, False)
        else:
            raise NotImplementedError

    def __and__(left, right):
        """
        Intersect two orders. 
        """
        if isinstance(left, AbsoluteOrder):
            return left & right._absolute_order
        elif isinstance(right, AbsoluteOrder):
            return left._absolute_order & right
        elif isinstance(left, RelativeOrder) and isinstance(right, RelativeOrder):
            if left._K != right._K:
                raise TypeError, "Number fields don't match."
            if left._base != right._base:
                raise TypeError, "Bases don't match."
            if left._embedding != right._embedding:
                raise TypeError, "Embeddings don't match."
            return RelativeOrder(left._absolute_order & right._absolute_order, left._base, left._embedding, False)
        else:
            raise NotImplementedError





def each_is_integral(v):
    """
    Return True if each element of the list v of elements
    of a number field is integral.
    """
    for x in v:
        if not x.is_integral():
            return False
    return True

from sage.rings.monomials import monomials

def absolute_order_from_ring_generators(gens, check_is_integral=True,
                                        check_rank=True):
    """
    INPUT:
        gens -- list of integral elements of an absolute order.
        check_is_integral -- bool (default: True), whether to check
                             that each generator is integral.
        check_rank -- bool (default: True), whether to check that
                      the ring generated by gens is of full rank.             
    """
    if check_is_integral and not each_is_integral(gens):
        raise ValueError, "each generator must be integral"
    gens = Sequence(gens)
    K = gens.universe()
    n = K.degree()
    module_gens = monomials(gens, n)
    return absolute_order_from_module_generators(module_gens,
               check_integral=False, check_is_ring=False,
               check_rank=check_rank)

        
def absolute_order_from_module_generators(gens, check_integral=True, check_rank=True, check_is_ring=True):
    """
    INPUT:
        gens -- list of elements of an absolute number field
                that generates an order in that number field as a ZZ
                *module*.
        check_integral -- check that each gen is integral
        check_rank -- check that the gens span a module of the correct rank
        check_is_ring -- check that the module is closed under multiplication
                         (this is very expensive)

    OUTPUT:
        an absolute order
    """
    if len(gens) == 0:
        raise ValueError, "gens must span an order over ZZ"
    gens = Sequence(gens)
    if check_integral and not each_is_integral(gens):
        raise ValueError, "each generator must be integral"
    
    K = gens.universe()
    V, _, to_V = K.vector_space()
    gens = [to_V(x) for x in gens]
    W = (ZZ**V.dimension()).span(gens)

    if check_rank:
        if W.rank() != K.degree():
            raise ValueError, "the rank of the span of gens is wrong"

    if check_is_ring:
        # Is there a faster way?
        alg = monomials(gens, K.degree())
        if V.span(alg) != W:
            raise ValueError, "the module span of the gens is not closed under multiplication."
        
    return AbsoluteOrder(K, W)
    

