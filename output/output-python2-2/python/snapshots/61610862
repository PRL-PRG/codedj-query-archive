r"""nodoctest
Multiplicative Abelian Groups

AUTHOR:
    -- David Joyner (2006-02) (based on free abelian monoids by David Kohel)

TODO:
   * subgroups must be a separate class:
         need to factor out functionality for ambient abelian groups
         and subgroups in a common base class.
   * additive abelian groups should also be supported

SAGE supports multiplicative abelian groups on any prescribed finite
number $n\geq 0$ of generators.  Use the \code{AbelianGroup} function
to create an abelian group, and the \code{gen} and \code{gens}
functions to obtain the corresponding generators.  You can print the
generators as arbitrary strings using the optional \code{names}
argument to the \code{AbelianGroup} function.

EXAMPLE 1:
We create an abelian group in zero or more variables; the syntax T(1)
creates the identity element even in the rank zero case.

    sage: T = AbelianGroup(0,[])
    sage: T
    Abelian group on 0 generators () with invariants []
    sage: T.gens()
    ()
    sage: T(1)
    1
 
EXAMPLE 2:
An abelian group uses a multiplicative representation of elements, but
the underlying representation is lists of integer exponents.

    sage: F = AbelianGroup(5,[3,4,5,5,7],names = list("abcde"))
    sage: F
    Abelian group on 5 generators (a, b, c, d, e) with invariants [3, 4, 5, 5, 7]
    sage: (a,b,c,d,e) = F.gens()
    sage: a*b^2*e*d
    a*b^2*d*e
    sage: x = b^2*e*d*a^7
    sage: x
    a*b^2*d*e
    sage: x.list()
    [1, 2, 0, 1, 1]
"""

##########################################################################
#  Copyright (C) 2006 David Joyner and William Stein
#
#  Distributed under the terms of the GNU General Public License (GPL):
#
#                  http://www.gnu.org/licenses/
##########################################################################

import weakref

from sage.ext.integer import Integer
from sage.rings.infinity import *
from sage.rings.arith import *
from abelian_group_element import AbelianGroupElement,is_AbelianGroupElement
from sage.misc.misc import add
import group

def AbelianGroup(n, invfac=None, names="f"):
    r"""
    Create the multiplicative abelian group in $n$ generators with
    invariants type.

    INPUT:
        n -- integer
        invfac -- (the "invariant factors") a list of integers 
                in the form [a1,a2,...,an], typically written in
                increasing order. 
        names -- (optional) names of generators

    Alternatively, you can also give input in the following form:
    
        AbelianGroup(invfac, names="f"),

    where names must be explicitly named.
        
    OUTPUT:
        Abelian group with generators and invariant type. The default name
        for the generators is f_i, as in GAP.

    EXAMPLES:
        sage: F = AbelianGroup(5, [5,5,7,8,9], names='abcde')
        sage: F(1)
        1
        sage: (a, b, c, d, e) = F.gens()
        sage: mul([ a, b, a, c, b, d, c, d ])
        a^2*b^2*c^2*d^2
        sage: d * b**2 * c**3 
        b^2*c^3*d
        sage: F = AbelianGroup(3,[2]*3); F
        Abelian group on 3 generators (f_0, f_1, f_2) with invariants [2, 2, 2]
    """
    if invfac is None and isinstance(n, (list, tuple)):
        invfac = n
        n = len(n)
    M = AbelianGroup_class(n, invfac, names)
    return M

def is_AbelianGroup(x):
    """
    Return True if $x$ is an abelian group.

    EXAMPLES:
        sage: F = AbelianGroup(5,[5,5,7,8,9],names = list("abcde")); F
        Abelian group on 5 generators (a, b, c, d, e) with invariants [5, 5, 7, 8, 9]
        sage: is_AbelianGroup(F)
        True
        sage: is_AbelianGroup(AbelianGroup(7, [3]*7))
        True
    """
    return isinstance(x, AbelianGroup_class)


# TODO: this should be a method of something; maybe of g in abelian_group_element?
#  
def word_problem(words, g, display=True):
    """
    G and H are abelian, g in G, H is a subgroup of G generated by a
    list (words) of elements of G. If g is in H, return the expression
    for g as a word in the elements of (words).

    The "word problem" for a finite abelian group G boils down to the following:

    Problem: Fix integers $1<n_1\leq n_2\leq ...\leq n_k$ (indeed, 
    these $n_i$ will all be prime powers), fix a generating set 
    $g_i=(a_{i1},...,a_{ik})$ (with $a_{ij}\in \Z/n_j\Z$),
    for $1\leq i\leq \ell$, for the group $G$, and let 
    $d = (d_1,...,d_k)$ be an element of the direct product
    $\Z/n_1\Z \times ...\times \Z/n_k\Z$. Find, if they exist,
    integers $c_1,...,c_\ell$ such that 
    $c_1g_1+...+c_\ell g_\ell = d$. In other words, solve the
    equation $cA=d$ for $c\in \Z^\ell$, where $A$ is the matrix whose 
    rows are the $g_i$'s. Of course, it suffices to restrict the $c_i$'s
    to the range $0\leq c_i\leq N-1$, where $N$ denotes the least common
    multiple of the integers $n_1,...,n_k$.

    This function does not solve this directly, as perhaps it should. Rather 
    (for both speed and as a model for a similar function valid for more 
    general groups), it pushes it over to GAP, which has optimized algorithms for
    the word problem. Essentially, this function is a wrapper for the GAP
    function "Factorization". Better perhaps would be to use
    "IsomorphismfFpGroupByGenerators", or (even better for large groups) 
    "EpimorphismFromFreeGroup" and "PreImagesRepresentative".

    EXAMPLE:
        sage: G = AbelianGroup(3,[2,3,4],names="abc"); G
        Abelian group on 3 generators (a, b, c) with invariants [2, 3, 4]
        sage: a,b,c=G.gens()
        sage: word_problem([a*b,a*c],b*c)
        b*c = (a*b)^1*(a*c)^1
        [[a*b, 1], [a*c, 1]]
        sage: word_problem([a*b,a*c],b*c,display=False)
        [[a*b, 1], [a*c, 1]]

    """
    from sage.groups.permgroup import PermutationGroup
    from sage.interfaces.all import gap
    G = g.parent()
    invs = G.invariants()
    gap.eval("l:=One(Rationals)")
    s1 = 'A:=AbelianGroup(%s)'%invs
    gap.eval(s1)
    s2 = 'phi:=IsomorphismPermGroup(A)'
    gap.eval(s2)
    s3 = "gens := GeneratorsOfGroup(A)"
    gap.eval(s3)
    L = g.list()
    gap.eval("L1:="+str(L))
    s4 = "L2:=List([l..%s], i->gens[i]^L1[i]);"%len(L) 
    gap.eval(s4)
    gap.eval("g:=Product(L2); gensH:=[]")
    for w in words:
         L = w.list()
         gap.eval("L1:="+str(L))
         s4 = "L2:=List([1..%s], i->gens[i]^L1[i]);"%len(L) 
         gap.eval(s4)
         gap.eval("w:=Product(L2)")
         gap.eval("gensH:=Concatenation(gensH,[w])")
    s5 = 'H:=Group(gensH)'
    gap.eval(s5)
    gap.eval("x:=Factorization(H,g)")
    l3 = gap.eval("L3:=ExtRepOfObj(x)")
    nn = gap.eval("n:=Int(Length(L3)/2)")
    LL = eval(gap.eval("L4:=List([l..n],i->L3[2*i])"))
    if display:
        s = str(g)+" = "+add(["("+str(words[i])+")^"+str(LL[i])+"*" for i in range(len(LL))])
        m = len(s)
        print "      ",s[:m-1]
    return [[words[i],LL[i]] for i in range(len(LL))]

class AbelianGroup_class(group.AbelianGroup):
    """
    Free abelian group on $n$ generators. The invariant factors 
    [a1,a2,...,ak] must be a list of prime powers.

    EXAMPLES:
        sage: F = AbelianGroup(5,[5,5,7,8,9],names = list("abcde")); F
        Abelian group on 5 generators (a, b, c, d, e) with invariants [5, 5, 7, 8, 9]
        sage: F = AbelianGroup(5,[2, 4, 12, 24, 120],names = list("abcde")); F
	Traceback (most recent call last):
        ...
	ValueError: invariant factors a_i (=[2, 4, 12, 24, 120])  must be prime powers.

    Thus we see that the "invariants" are not the invariant factors but
    the "elementary divisors" (in the terminology of Rotman).
    """
    def __init__(self, n, invfac, names="f"):
        if not isinstance(n, (int, long, Integer)):
            raise TypeError, "n (=%s) must be an integer."%n
        if n < 0:
            raise ValueError, "n (=%s) must be nonnegative."%n
        self.__ngens = int(n)
        self.assign_names(names)
        for i in range(len(invfac)):
           if invfac[i]>1 and len(prime_factors(invfac[i]))!=1:
               raise ValueError, "invariant factors a_i (=%s)  must be prime powers."%invfac
        self.invariant = invfac

    def invariants(self):
        return self.invariant

##     def is_subgroup(self, other):
##         """
##         returns true or false

##         EXAMPLES:
##             sage: G = AbelianGroup(3,[2,3,4], names="abc"); G
##             Abelian group on 3 generators (a, b, c) with invariants [2, 3, 4]
##             sage: a,b,c = G.gens()
##             sage: H = G.subgroup([a*b,a])
##             sage: H < G
##             True
##             sage: G.is_subgroup(H)
##             True
##             sage: K = AbelianGroup(4,[5,2,3,4], names="abcd"); G
##             Abelian group on 3 generators (a, b, c) with invariants [2, 3, 4]
##             sage: G < K
##             True
##         """
##         for x in self.gens():
##             if not x in other:
##                 return False
##         return True

    def __repr__(self):
        """
        Print method.

        EXAMPLES:
            sage: F = AbelianGroup(5,[5,64,729],names = list("abcde")); F
            Abelian group on 5 generators (a, b, c, d, e) with invariants [5, 64, 729, Infinity, Infinity]
	    sage: F = AbelianGroup(5,[1,1,5,64,729],names = list("abcde")); F
            Abelian group on 5 generators (a, b, c, d, e) with invariants [1, 1, 5, 64, 729]
        """
        n = self.__ngens
        invs = self.invariants()
        m = len(invs)
        if m==n:
            return "Abelian group on %s generators %s with invariants %s"%(n,self.gens(),invs)
        else:
            invs = self.invariants()+[Infinity()]*(n-m) 
            return "Abelian group on %s generators %s with invariants %s"%(n,self.gens(),invs)        

    def __call__(self, x):
        """
        Create an element of this abelian group from $x$.

        EXAMPLES:
            sage: F = AbelianGroup(10, [2]*10)
            sage: F(F.gen(2))
            f_2
            sage: F(1)
            1
        """
        if isinstance(x, AbelianGroupElement) and x.parent() is self: 
            return x
        return AbelianGroupElement(self, x)
                                
    def __contains__(self, x):
        """
        Return True if $x$ is an element of this abelian group.

        EXAMPLES:
            sage: F = AbelianGroup(10,[2]*10)
            sage: F.gen(2)*F.gen(3) in F
            True
        """
        return isinstance(x, AbelianGroupElement) and x.parent() == self

    def _gap_init_(self):
        """
        Return string that defines corresponding abelian group in GAP.

        EXAMPLES:
            sage: G = AbelianGroup([2,3,9])
            sage: G._gap_init_()
            'AbelianGroup([2, 3, 9])'
            sage: gap(G)
            <pc group of size 54 with 3 generators>
        """
        if not self.is_finite():
            raise TypeError, "abelian groups in gap are finite, but self is infinite"
        return 'AbelianGroup(%s)'%self.invariants()

    def gen(self, i=0):
        """
        The $i$-th generator of the abelian group.
        
        EXAMPLES:
            sage: F = AbelianGroup(5,[],names='a')
            sage: F.gen(0)
            a_0
            sage: F.gen(2)
            a_2
            sage: F.invariants()
            []
        """
        n = self.__ngens
        if i < 0 or i >= n: 
            raise IndexError, "Argument i (= %s) must be between 0 and %s."%(i, n-1)
        x = [0]*int(n)
        x[int(i)] = 1 
        return AbelianGroupElement(self, x)
    
    def ngens(self):
        """
        The number of free generators of the abelian group.

        EXAMPLES:
            sage: F = AbelianGroup(3000,[])
            sage: F.ngens()
            3000
        """
        return self.__ngens

    def order(self):
        """
        Return the order of this group.

        EXAMPLES:
            sage: G = AbelianGroup(2,[2,3])
            sage: G.order()
            6
            sage: G = AbelianGroup(3,[2,3,0])
            sage: G.order()
            Infinity
        """
        import sage.rings.all
        try:
            return self.__len
        except AttributeError:
            if len(self.invariants()) < self.ngens():
                self.__len = sage.rings.all.infinity
            self.__len = sage.misc.misc.mul(self.invariants())
            if self.__len == 0:
                self.__len = sage.rings.all.infinity
        return self.__len

    def permutation_group(self):
        r"""
        Return the permutation group isomorphic to this abelian group.

        If the invariants are $q_1, \ldots, q_n$ then the generators
        of the permutation will be of order $q_1, \ldots, q_n$,
        respectively.
        
        EXAMPLES:
            sage: G = AbelianGroup(2,[2,3]); G
            Abelian group on 2 generators (f_0, f_1) with invariants [2, 3]
            sage: G.permutation_group()
            Permutation Group with generators [(1,4)(2,5)(3,6), (1,2,3)(4,5,6)]
        """
        from sage.groups.permgroup import PermutationGroup
        from sage.interfaces.all import gap
        invs = self.invariants()
        s = 'Image(IsomorphismPermGroup(%s))'%self._gap_init_()
        return PermutationGroup(s, from_group=True)

    def as_permutation(self, a):
        r"""
        Return the element of the permutation group G (isomorphic to the
        abelian group A) associated to a in A.

        EXAMPLES:
	    sage: G = AbelianGroup(3,[2,3,4],names="abc"); G
            Abelian group on 3 generators (a, b, c) with invariants [2, 3, 4]
            sage: a,b,c=G.gens()
            sage: Gp = G.permutation_group()
            sage: G.as_permutation(a)
            (1,13)(2,14)(3,15)(4,16)(5,17)(6,18)(7,19)(8,20)(9,21)(10,22)(11,23)(12,24)
            sage: g = G.as_permutation(a)
            sage: g in Gp
            True
        """
        from sage.groups.permgroup import PermutationGroup
        from sage.interfaces.all import gap
        invs = self.invariants()
        s1 = 'A:=AbelianGroup(%s)'%invs
        gap.eval(s1)
        s2 = 'phi:=IsomorphismPermGroup(A)'
        gap.eval(s2)
        s3 = "gens := GeneratorsOfGroup(A)"
        gap.eval(s3)
        L = a.list()
        gap.eval("L1:="+str(L))
        s4 = "L2:=List([1..%s], i->gens[i]^L1[i]);"%len(L)
        gap.eval(s4)
        pg = gap.eval("Image(phi,Product(L2))")
        Gp = self.permutation_group()
        gp = Gp(pg)
        return gp

    def is_commutative(self):
        """
        Return True since this group is commutative.

        EXAMPLES:
            sage: G = AbelianGroup([2,3,9, 0])
            sage: G.is_commutative()
            True
            sage: G.is_abelian()
            True
        """
        return True

# TODO: subgroups need to be a separate class (see remarks at the top of this file)

##     def subgroup(self, gensH):
##         """
##         Create a subgroup of this group.

##         INPUT:
##             gensH -- list of elements which are products of the
##                      generators of the ambient abelian group G = self

##         EXAMPLES:
##             sage: G = AbelianGroup(3, [2,3,4], names="abc"); G
##             Abelian group on 3 generators (a, b, c) with invariants [2, 3, 4]
##             sage: a,b,c = G.gens()
##             sage: H = G.subgroup([a*b,a]); H
##             Abelian group on 2 generators (f_0, f_1) with invariants [2, 3]
##             sage: H.is_subgroup(G)
##             True
##             sage: H < G
##             True
##         """
##         if not isinstance(gensH, (list, tuple)):
##             raise TypeError, "gensH = (%s) must be a list or tuple"%(gensH)
            
##         from permgroup import PermutationGroup
##         from sage.interfaces.all import gap
##         G = self
##         for i in range(len(gensH)):
##             if not(gensH[i] in G):
##                 raise TypeError, "Subgroup generators must belong to the given group."
##         ## map gensH over to GAP, find the invariants of H, then map this back to SAGE. 
##         Gp = G.permutation_group()
##         gensGp = Gp.gens()
##         gensHp = []
##         for i in range(len(gensH)):
##             gensHp.append(G.as_permutation(gensH[i]))
##         Hp = PermutationGroup(gensHp)
##         s1 = "H := Group(%s)"%gensHp
##         gap.eval(s1)
##         s2 = "AbelianInvariants(H)"
##         invs = gap.eval(s2)
##         invs = eval(invs)
##         return AbelianGroup(len(invs), invs)

    def __cmp__(self, right):
       """
       Compare self and right.
    
       The ordering is the ordering induced by that on the invariant factors lists.
       
       EXAMPLES:
           sage: G1 = AbelianGroup(4,[2,3,4,5])
           sage: G2 = AbelianGroup(5,[2,3,4,5,1])
           sage: G1 < G2
           True
           sage: G1 > G2
           False
       """
       if not is_AbelianGroup(right):
           return -1
       return cmp(self.invariants(), right.invariants())
                  
       
class AbelianGroup_subgroup:
    pass
