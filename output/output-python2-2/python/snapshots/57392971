#! /usr/bin/python
# Copyright 2004 Roman Yakovenko.
# Distributed under the Boost Software License, Version 1.0. (See
# accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

import os
import md5
import time
import cPickle 
from pygccxml.utils import logger


def file_signature( filename ):
    if not os.path.isfile( filename ):
        return None
    if not os.path.exists( filename ):
        return None
    # Extend here to use md5 hash for signature
    # - This change allows duplicate autogenerated files to be recognized
    #return os.path.getmtime( source )
    sig = md5.new()
    f = file(filename,'r')
    sig.update(f.read())
    f.close()    
    return sig.hexdigest()

class cache_base_t( object ):
    def __init__( self ):
        object.__init__(self)
        
    def flush(self):
        raise NotImplementedError()
        
    def update(self, source_file, configuration, declarations, included_files):
        raise NotImplementedError()    
        
    def cached_value(self, source_file, configuration):
        #returns declarations, types
        raise NotImplementedError()

class record_t( object ):
    def __init__( self
                  , source_signature
                  , working_directory
                  , include_paths
                  , define_symbols
                  , included_files
                  , included_files_signature
                  , declarations ):
        self.__source_signature = source_signature
        self.__working_directory = working_directory
        self.__include_paths = include_paths
        self.__define_symbols = define_symbols
        self.__included_files = included_files
        self.__included_files_signature = included_files_signature
        self.__declarations = declarations
        self.__was_hit = True # Track if there was a cache hit
    
    def _get_was_hit(self):
        return self.__was_hit
    def _set_was_hit(self, was_hit):
        self.__was_hit = was_hit
    was_hit = property( _get_was_hit, _set_was_hit )
    
    def key(self):
        return ( self.__source_signature
                 , self.__working_directory
                 , tuple(self.__include_paths)
                 , tuple(self.__define_symbols ) )
    
    def create_key( source_file, configuration ):
        return ( file_signature(source_file)
                 , configuration.working_directory
                 , tuple( configuration.include_paths )
                 , tuple( configuration.define_symbols ) )
    create_key = staticmethod( create_key )
    
    #def value(self):
        #return ( self.__source_file_signature
                 #, self.__included_files
                 #, self.__included_files_signature
                 #, self.__declarations )
    
    #def create( key, value ):
        #return record_t( source_file=key[0]
                         #, working_directory=key[1]
                         #, include_paths=list(key[2])
                         #, define_symbols=list(key[3])
                         #, source_file_signature=value[0]
                         #, included_files=value[1]
                         #, included_files_signature=value[2]
                         #, declarations=value[3] )
    #create = staticmethod(create)

    def __source_signature(self):
        return self.__source_signature
    source_signature = property( __source_signature )
    
    def __source_file(self):
        return self.__source_file
    source_file = property( __source_file )
    
    def __working_directory(self):
        return self.__working_directory
    working_directory = property( __working_directory )        
    
    def __include_paths(self):
        return self.__include_paths
    include_paths = property( __include_paths )
    
    def __define_symbols(self):
        return self.__define_symbols
    define_symbols = property( __define_symbols )
    
    def __included_files(self):
        return self.__included_files
    included_files = property( __included_files )
    
    def __included_files_signature(self):
        return self.__included_files_signature
    included_files_signature = property( __included_files_signature )
           
    def __declarations(self):
        return self.__declarations
    declarations = property( __declarations )   

class file_cache_t( cache_base_t ):   
    """ Cache implementation to store data in a pickled form in a file. 
        This class contains some cache logic that keeps track of which entries
        have been 'hit' in the cache and if an entry has not been hit then
        it is deleted at the time of the flush().  This keeps the cache from
        growing larger when files change and are not used again.        
    """

    def __init__( self, name ):
        cache_base_t.__init__( self )
        self.__name = name
        self.__cache = self.__load( self.__name )
        self.__needs_flushed = bool( self.__cache ) # If empty then we need to flush        
        for entry in self.__cache.itervalues(): # Clear hit flags
            entry.was_hit = False
        
    def __load( file_name ):        
        cache = None
        if os.path.exists( file_name ) and not os.path.isfile( file_name ):
            raise RuntimeError( 'Cache should be initialized with valid full file name' )
        if not os.path.exists( file_name ):
            file( file_name, 'w+b' ).close()
            return {}
        cache_file_obj = file( file_name, 'rb' )
        try:
            logger.info( "Loading cache file ..." )
            start_time = time.clock()
            cache = cPickle.load( cache_file_obj )            
            logger.info( "Cache file has been loaded in %.1f secs"%( time.clock() - start_time ) )
            logger.info( "Found cache in file: [%s]  entries: %s"
                          % ( file_name, len( cache.keys() ) ) )
        except Exception:
            cache_file_obj.close()
            logger.info( "Invalid cache file: [%s]  Regenerating." % file_name )
            file(file_name, 'w+b').close()   # Create empty file
            cache = {}                       # Empty cache            
        return cache
    __load = staticmethod( __load )
        
    def flush(self):
        # Remove entries that did not get a cache hit
        if not self.__needs_flushed:
            return
        
        num_removed = 0
        for key in self.__cache.keys():
            if not self.__cache[key].was_hit:
                num_removed += 1
                del self.__cache[key]
        if num_removed > 0:
            logger.info(  "There are %s removed entries from cache." % num_removed )
        # Save out the cache to disk
        cache_file = file( self.__name, 'w+b' )
        cPickle.dump( self.__cache, cache_file, cPickle.HIGHEST_PROTOCOL )
        cache_file.close()

    def update(self, source_file, configuration, declarations, included_files):
        """ Update a cached record with the current key and value contents. """
        record = record_t( source_signature=file_signature(source_file)
                           , working_directory=configuration.working_directory
                           , include_paths=configuration.include_paths
                           , define_symbols=configuration.define_symbols
                           , included_files=included_files
                           , included_files_signature=map( file_signature, included_files)
                           , declarations=declarations 
                        )
        # Switched over to holding full record in cache so we don't have
        # to keep creating records in the next method.
        self.__cache[ record.key() ] = record
        self.__cache[ record.key() ].was_hit = True
        self.__needs_flushed = True
    
    def cached_value(self, source_file, configuration):
        """ Attempt to lookup the cached decls for the given file and configuration.
            If not found or signature check fails, returns None.
        """
        key = record_t.create_key(source_file, configuration)
        if not self.__cache.has_key( key ):
            return None
        record = self.__cache[key]
        if self.__is_valid_signature( record ):
            record.was_hit = True                  # Record cache hit
            return record.declarations
        else: #some file has been changed 
            del self.__cache[key]
            return None
        
    def __is_valid_signature( self, record ):
        # This is now part of key
        #if self.__signature( record.source_file ) != record.source_file_signature:
        #    return False
        for index, included_file in enumerate( record.included_files ):
            if file_signature( included_file ) != record.included_files_signature[index]:
                return False
        return True
        

class dummy_cache_t( cache_base_t ):
    def __init__( self ):
        cache_base_t.__init__(self)
        
    def flush(self):
        pass
        
    def update(self, source_file, configuration, declarations, included_files):
        pass
        
    def cached_value(self, source_file, configuration):
        return None
